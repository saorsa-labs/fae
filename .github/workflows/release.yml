name: Release

on:
  push:
    tags:
      - "v*"

env:
  CARGO_TERM_COLOR: always
  MACOSX_DEPLOYMENT_TARGET: '14.0'

permissions:
  contents: write

jobs:
  # ── Verify tag matches Cargo.toml version ──────────────────────────
  preflight:
    name: Pre-flight
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Verify tag matches Cargo.toml version
        id: version
        run: |
          TAG_VERSION="${GITHUB_REF#refs/tags/v}"
          CARGO_VERSION=$(grep -m1 '^version' Cargo.toml | sed 's/.*"\(.*\)".*/\1/')
          if [ "$TAG_VERSION" != "$CARGO_VERSION" ]; then
            echo "::error::Tag version ($TAG_VERSION) does not match Cargo.toml ($CARGO_VERSION)"
            exit 1
          fi
          echo "version=$CARGO_VERSION" >> "$GITHUB_OUTPUT"
          echo "Releasing v$CARGO_VERSION"

  # ── Run full test suite before building release artifacts ──────────
  test:
    name: Tests
    needs: preflight
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Run tests
        run: cargo test --no-default-features

  # ── Build macOS binary (Apple Silicon) ─────────────────────────────
  build-macos:
    name: Build macOS (arm64)
    needs: test
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry & build
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-aarch64-release-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-aarch64-release-

      - name: Build libfae.a static library
        run: |
          rustup target add aarch64-apple-darwin
          cargo build --release --target aarch64-apple-darwin --lib
          if [ ! -f "target/aarch64-apple-darwin/release/libfae.a" ]; then
            echo "::error::libfae.a not found after build"
            exit 1
          fi
          echo "Built libfae.a: $(du -h target/aarch64-apple-darwin/release/libfae.a | cut -f1)"

      - name: Build native Swift shell (links against libfae.a)
        run: |
          pushd native/macos/FaeNativeApp
          swift build -c release
          SWIFT_BIN_REL="$(find .build -type f -perm -111 -name FaeNativeApp | head -n 1)"
          if [ -z "$SWIFT_BIN_REL" ]; then
            echo "::error::Could not locate built FaeNativeApp binary under native/macos/FaeNativeApp/.build"
            exit 1
          fi
          SWIFT_BIN_ABS="$(cd "$(dirname "$SWIFT_BIN_REL")" && pwd)/$(basename "$SWIFT_BIN_REL")"
          echo "SWIFT_APP_BINARY=$SWIFT_BIN_ABS" >> "$GITHUB_ENV"

          SWIFT_RES_REL="$(find .build -type d -name 'FaeNativeApp_FaeNativeApp.bundle' | head -n 1)"
          if [ -z "$SWIFT_RES_REL" ]; then
            echo "::error::Could not locate FaeNativeApp_FaeNativeApp.bundle resource bundle"
            exit 1
          fi
          SWIFT_RES_ABS="$(cd "$SWIFT_RES_REL" && pwd)"
          echo "SWIFT_RESOURCE_BUNDLE=$SWIFT_RES_ABS" >> "$GITHUB_ENV"
          popd

      - name: Import signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          if [ -z "$MACOS_CERTIFICATE" ] || [ -z "$MACOS_CERTIFICATE_PASSWORD" ] || [ -z "$KEYCHAIN_PASSWORD" ]; then
            echo "::error::macOS signing secrets are required (MACOS_CERTIFICATE, MACOS_CERTIFICATE_PASSWORD, KEYCHAIN_PASSWORD)"
            exit 1
          fi

          echo "SIGNING_ENABLED=true" >> "$GITHUB_ENV"

          CERTIFICATE_PATH="$RUNNER_TEMP/build_certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"

          echo -n "$MACOS_CERTIFICATE" | base64 --decode -o "$CERTIFICATE_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security import "$CERTIFICATE_PATH" \
            -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" \
            "$KEYCHAIN_PATH"

          security list-keychain -d user -s "$KEYCHAIN_PATH"

      - name: Sign binaries
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
        run: |
          if [ -z "$MACOS_SIGNING_IDENTITY" ]; then
            echo "::error::MACOS_SIGNING_IDENTITY is required for signed releases"
            exit 1
          fi

          codesign --force --options runtime \
            --sign "$MACOS_SIGNING_IDENTITY" \
            --entitlements Entitlements.plist \
            --timestamp \
            "$SWIFT_APP_BINARY"

      - name: Notarize binaries
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_NOTARIZATION_APPLE_ID: ${{ secrets.MACOS_NOTARIZATION_APPLE_ID }}
          MACOS_NOTARIZATION_PASSWORD: ${{ secrets.MACOS_NOTARIZATION_PASSWORD }}
          MACOS_NOTARIZATION_TEAM_ID: ${{ secrets.MACOS_NOTARIZATION_TEAM_ID }}
        run: |
          if [ -z "$MACOS_NOTARIZATION_APPLE_ID" ] || [ -z "$MACOS_NOTARIZATION_PASSWORD" ] || [ -z "$MACOS_NOTARIZATION_TEAM_ID" ]; then
            echo "::error::macOS notarization secrets are required (MACOS_NOTARIZATION_APPLE_ID, MACOS_NOTARIZATION_PASSWORD, MACOS_NOTARIZATION_TEAM_ID)"
            exit 1
          fi

          NOTARIZE_ZIP="$RUNNER_TEMP/fae-native-swift-notarize.zip"
          ditto -c -k --keepParent "$SWIFT_APP_BINARY" "$NOTARIZE_ZIP"

          xcrun notarytool submit "$NOTARIZE_ZIP" \
            --apple-id "$MACOS_NOTARIZATION_APPLE_ID" \
            --password "$MACOS_NOTARIZATION_PASSWORD" \
            --team-id "$MACOS_NOTARIZATION_TEAM_ID" \
            --wait

      - name: Prepare release payloads
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          DIST_DIR="$RUNNER_TEMP/fae-dist"
          APP_BUNDLE="$RUNNER_TEMP/Fae.app"
          ARCHIVE_STAGING="$RUNNER_TEMP/fae-archive-staging"
          ARCHIVE="$DIST_DIR/fae-${VERSION}-macos-arm64.tar.gz"
          UPDATE_ASSET="$DIST_DIR/fae-darwin-aarch64"

          rm -rf "$DIST_DIR" "$APP_BUNDLE" "$ARCHIVE_STAGING"
          mkdir -p "$DIST_DIR" "$ARCHIVE_STAGING"
          mkdir -p "$APP_BUNDLE/Contents/MacOS" "$APP_BUNDLE/Contents/Resources"

          # Standalone binary used by in-app self-update.
          cp "$SWIFT_APP_BINARY" "$UPDATE_ASSET"
          chmod +x "$UPDATE_ASSET"

          # Build native macOS app bundle (single binary — Rust core is statically linked).
          cp "$SWIFT_APP_BINARY" "$APP_BUNDLE/Contents/MacOS/FaeNativeApp"
          cp assets/AppIcon.icns "$APP_BUNDLE/Contents/Resources/AppIcon.icns"
          cp -R "$SWIFT_RESOURCE_BUNDLE" "$APP_BUNDLE/Contents/Resources/"
          chmod +x "$APP_BUNDLE/Contents/MacOS/FaeNativeApp"

          # Use checked-in Info.plist with version substitution.
          cp native/macos/FaeNativeApp/Info.plist "$APP_BUNDLE/Contents/Info.plist"
          sed -i '' "s/__VERSION__/${VERSION}/g" "$APP_BUNDLE/Contents/Info.plist"

          # Archive includes native app bundle.
          cp -R "$APP_BUNDLE" "$ARCHIVE_STAGING/Fae.app"
          cp README.md "$ARCHIVE_STAGING/"
          cp LICENSE "$ARCHIVE_STAGING/" 2>/dev/null || true
          tar -czf "$ARCHIVE" -C "$ARCHIVE_STAGING" .

          echo "DIST_DIR=$DIST_DIR" >> "$GITHUB_ENV"
          echo "APP_BUNDLE=$APP_BUNDLE" >> "$GITHUB_ENV"
          echo "ARCHIVE=$ARCHIVE" >> "$GITHUB_ENV"
          echo "UPDATE_ASSET=$UPDATE_ASSET" >> "$GITHUB_ENV"

      - name: Sign app bundle
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
        run: |
          # Sign inside-out: nested bundles first, then binary, then top-level .app.

          # 1. SPM resource bundles contain static assets (HTML, CSS, images)
          # and lack the Info.plist structure codesign requires. They are sealed
          # by the top-level .app signature in step 4, so skip individual signing.

          # 2. Sign the main executable inside the bundle.
          codesign --force --options runtime \
            --sign "$MACOS_SIGNING_IDENTITY" \
            --entitlements Entitlements.plist \
            --timestamp \
            "$APP_BUNDLE/Contents/MacOS/FaeNativeApp"

          # 3. Sign the standalone update binary (not in a bundle).
          codesign --force --options runtime \
            --sign "$MACOS_SIGNING_IDENTITY" \
            --entitlements Entitlements.plist \
            --timestamp \
            "$UPDATE_ASSET"

          # 4. Sign the top-level .app bundle (seals everything).
          codesign --force --options runtime \
            --sign "$MACOS_SIGNING_IDENTITY" \
            --entitlements Entitlements.plist \
            --timestamp \
            "$APP_BUNDLE"

          codesign --verify --deep --strict --verbose=2 "$APP_BUNDLE"
          spctl -a -vvv --type execute "$APP_BUNDLE"

      - name: Build macOS installer (.dmg)
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          DMG_STAGING="$RUNNER_TEMP/fae-dmg-staging"
          INSTALLER_DMG="$DIST_DIR/fae-${VERSION}-macos-arm64.dmg"

          rm -rf "$DMG_STAGING" "$INSTALLER_DMG"
          mkdir -p "$DMG_STAGING"
          cp -R "$APP_BUNDLE" "$DMG_STAGING/Fae.app"
          ln -s /Applications "$DMG_STAGING/Applications"

          hdiutil create \
            -volname "Fae" \
            -srcfolder "$DMG_STAGING" \
            -ov \
            -format UDZO \
            "$INSTALLER_DMG"

          echo "INSTALLER_DMG=$INSTALLER_DMG" >> "$GITHUB_ENV"

      - name: Notarize installer (.dmg)
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_NOTARIZATION_APPLE_ID: ${{ secrets.MACOS_NOTARIZATION_APPLE_ID }}
          MACOS_NOTARIZATION_PASSWORD: ${{ secrets.MACOS_NOTARIZATION_PASSWORD }}
          MACOS_NOTARIZATION_TEAM_ID: ${{ secrets.MACOS_NOTARIZATION_TEAM_ID }}
        run: |
          xcrun notarytool submit "$INSTALLER_DMG" \
            --apple-id "$MACOS_NOTARIZATION_APPLE_ID" \
            --password "$MACOS_NOTARIZATION_PASSWORD" \
            --team-id "$MACOS_NOTARIZATION_TEAM_ID" \
            --wait
          xcrun stapler staple "$INSTALLER_DMG"

      - name: Generate Sparkle EdDSA signature for DMG
        env:
          SPARKLE_KEY: ${{ secrets.SPARKLE_KEY }}
        run: |
          if [ -z "$SPARKLE_KEY" ]; then
            echo "::warning::SPARKLE_KEY not set — skipping Sparkle signature"
            echo "SPARKLE_SIGNATURE=" >> "$GITHUB_ENV"
          else
            # Sparkle's sign_update is bundled in the SPM checkout.
            SIGN_UPDATE="$(find native/macos/FaeNativeApp/.build -path '*/Sparkle/bin/sign_update' -type f 2>/dev/null | head -n 1)"
            if [ -z "$SIGN_UPDATE" ] || [ ! -x "$SIGN_UPDATE" ]; then
              # Fall back to downloading Sparkle CLI tools.
              curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz" \
                | tar xJ -C "$RUNNER_TEMP" bin/sign_update
              SIGN_UPDATE="$RUNNER_TEMP/bin/sign_update"
              chmod +x "$SIGN_UPDATE"
            fi

            DMG_SIZE=$(stat -f%z "$INSTALLER_DMG" 2>/dev/null || stat --format=%s "$INSTALLER_DMG")
            SIGNATURE=$("$SIGN_UPDATE" "$INSTALLER_DMG" --ed-key-file <(echo "$SPARKLE_KEY") 2>/dev/null || echo "")
            echo "SPARKLE_SIGNATURE=$SIGNATURE" >> "$GITHUB_ENV"
            echo "DMG_SIZE=$DMG_SIZE" >> "$GITHUB_ENV"
            echo "Sparkle signature generated (${#SIGNATURE} chars)"
          fi

      - name: Stage release artifacts
        run: |
          ARTIFACTS_DIR="$RUNNER_TEMP/release-artifacts"
          rm -rf "$ARTIFACTS_DIR"
          mkdir -p "$ARTIFACTS_DIR"

          cp "$ARCHIVE" "$ARTIFACTS_DIR/"
          cp "$INSTALLER_DMG" "$ARTIFACTS_DIR/"
          cp "$UPDATE_ASSET" "$ARTIFACTS_DIR/"

          # Generate Sparkle appcast.xml if signature available.
          if [ -n "$SPARKLE_SIGNATURE" ]; then
            VERSION="${GITHUB_REF#refs/tags/v}"
            DMG_FILENAME="fae-${VERSION}-macos-arm64.dmg"
            REPO="${GITHUB_REPOSITORY}"
            DOWNLOAD_URL="https://github.com/${REPO}/releases/download/v${VERSION}/${DMG_FILENAME}"

            cat > "$ARTIFACTS_DIR/appcast.xml" << APPCAST_EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Fae Updates</title>
              <link>https://github.com/${REPO}/releases</link>
              <description>Fae automatic updates</description>
              <language>en</language>
              <item>
                <title>Version ${VERSION}</title>
                <sparkle:version>${VERSION}</sparkle:version>
                <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
                <pubDate>$(date -R)</pubDate>
                <enclosure
                  url="${DOWNLOAD_URL}"
                  sparkle:edSignature="${SPARKLE_SIGNATURE}"
                  length="${DMG_SIZE}"
                  type="application/octet-stream" />
              </item>
            </channel>
          </rss>
          APPCAST_EOF
            echo "Generated appcast.xml for v${VERSION}"
          fi

          echo "ARTIFACTS_DIR=$ARTIFACTS_DIR" >> "$GITHUB_ENV"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: fae-macos-arm64
          path: ${{ env.ARTIFACTS_DIR }}/*

  # ── Build Linux binary (x86_64) ────────────────────────────────────
  build-linux:
    name: Build Linux (x86_64)
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install Linux build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            libasound2-dev \
            libssl-dev \
            libfontconfig1-dev

      - name: Cache cargo registry & build
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-x86_64-release-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-x86_64-release-

      - name: Build release binary (headless host bridge)
        run: cargo build --release --bin fae-host

      - name: Prepare release payloads
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          DIST_DIR="$RUNNER_TEMP/fae-dist"
          ARCHIVE_STAGING="$RUNNER_TEMP/fae-archive-staging"
          ARCHIVE="$DIST_DIR/fae-${VERSION}-linux-x86_64.tar.gz"
          UPDATE_ASSET="$DIST_DIR/fae-linux-x86_64"

          rm -rf "$DIST_DIR" "$ARCHIVE_STAGING"
          mkdir -p "$DIST_DIR" "$ARCHIVE_STAGING"

          cp target/release/fae-host "$UPDATE_ASSET"
          chmod +x "$UPDATE_ASSET"

          cp target/release/fae-host "$ARCHIVE_STAGING/fae-host"
          cp README.md "$ARCHIVE_STAGING/"
          cp LICENSE "$ARCHIVE_STAGING/" 2>/dev/null || true
          chmod +x "$ARCHIVE_STAGING/fae-host"
          tar -czf "$ARCHIVE" -C "$ARCHIVE_STAGING" .

          echo "ARTIFACTS_DIR=$DIST_DIR" >> "$GITHUB_ENV"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: fae-linux-x86_64
          path: ${{ env.ARTIFACTS_DIR }}/*

  # ── Build Windows binary (x86_64) ──────────────────────────────────
  build-windows:
    name: Build Windows (x86_64)
    needs: test
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry & build
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-x86_64-release-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-x86_64-release-

      - name: Build release binary (headless host bridge)
        run: cargo build --release --bin fae-host

      - name: Prepare release payloads
        shell: pwsh
        run: |
          $Version = "${env:GITHUB_REF}".Replace("refs/tags/v", "")
          $DistDir = Join-Path $env:RUNNER_TEMP "fae-dist"
          $ArchiveStaging = Join-Path $env:RUNNER_TEMP "fae-archive-staging"
          $Archive = Join-Path $DistDir "fae-$Version-windows-x86_64.zip"
          $UpdateAsset = Join-Path $DistDir "fae-windows-x86_64.exe"

          Remove-Item -Recurse -Force $DistDir, $ArchiveStaging -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Force -Path $DistDir | Out-Null
          New-Item -ItemType Directory -Force -Path $ArchiveStaging | Out-Null

          Copy-Item "target/release/fae-host.exe" $UpdateAsset
          Copy-Item "target/release/fae-host.exe" (Join-Path $ArchiveStaging "fae-host.exe")
          Copy-Item "README.md" $ArchiveStaging
          if (Test-Path "LICENSE") {
            Copy-Item "LICENSE" $ArchiveStaging
          }

          Compress-Archive -Path (Join-Path $ArchiveStaging "*") -DestinationPath $Archive -Force
          "ARTIFACTS_DIR=$DistDir" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: fae-windows-x86_64
          path: ${{ env.ARTIFACTS_DIR }}/*

  # ── Create GitHub Release with all artifacts ───────────────────────
  release:
    name: Create Release
    needs: [build-macos, build-linux, build-windows]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: find artifacts -type f

      - name: Generate checksums
        run: |
          cd artifacts
          find . -type f ! -name 'SHA256SUMS.txt' -print0 | sort -z | xargs -0 sha256sum > SHA256SUMS.txt
          cat SHA256SUMS.txt

      - name: Sign checksums with GPG
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          if [ -z "$GPG_PRIVATE_KEY" ] || [ -z "$GPG_PASSPHRASE" ]; then
            echo "::error::GPG_PRIVATE_KEY and GPG_PASSPHRASE secrets are required for release signing"
            exit 1
          fi

          cd artifacts
          export GNUPGHOME="$RUNNER_TEMP/gnupg-release-signing"
          mkdir -p "$GNUPGHOME"
          chmod 700 "$GNUPGHOME"

          KEY_FILE="$RUNNER_TEMP/release-signing-key.asc"
          printf "%s" "$GPG_PRIVATE_KEY" > "$KEY_FILE"
          if ! gpg --batch --import "$KEY_FILE" >/dev/null 2>&1; then
            DECODED_KEY_FILE="$RUNNER_TEMP/release-signing-key.decoded.asc"
            if ! base64 --decode "$KEY_FILE" > "$DECODED_KEY_FILE" 2>/dev/null || ! gpg --batch --import "$DECODED_KEY_FILE"; then
              echo "::error::failed to import GPG_PRIVATE_KEY (expected armored key or base64-encoded armored key)"
              exit 1
            fi
          fi

          KEY_FPR="$(gpg --batch --with-colons --list-secret-keys | awk -F: '/^fpr:/ {print $10; exit}')"
          if [ -z "$KEY_FPR" ]; then
            echo "::error::could not determine signing key fingerprint"
            exit 1
          fi

          gpg --batch --yes \
            --pinentry-mode loopback \
            --passphrase "$GPG_PASSPHRASE" \
            --local-user "$KEY_FPR" \
            --armor --detach-sign \
            --output SHA256SUMS.txt.asc \
            SHA256SUMS.txt

          gpg --batch --verify SHA256SUMS.txt.asc SHA256SUMS.txt
          gpg --batch --armor --export "$KEY_FPR" > FAE_UPDATE_SIGNING_KEY.asc

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
            artifacts/**/*.dmg
            artifacts/**/fae-darwin-aarch64
            artifacts/**/fae-linux-x86_64
            artifacts/**/fae-windows-x86_64.exe
            artifacts/**/appcast.xml
            artifacts/SHA256SUMS.txt
            artifacts/SHA256SUMS.txt.asc
            artifacts/FAE_UPDATE_SIGNING_KEY.asc
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
