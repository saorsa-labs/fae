<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Fae Conversation</title>
<style>
  /* =========================================================
     Global Reset and Base
     ========================================================= */
  :root {
    --bg: #0a0b0d;
    --label: rgba(200, 211, 213, 0.4);
    --hint: rgba(200, 211, 213, 0.22);
    --heather: #B4A8C4;
    --heather-rgb: 180, 168, 196;
    --text-primary: rgba(255, 255, 255, 0.92);
    --text-secondary: rgba(255, 255, 255, 0.6);
    --input-bar-height: 80px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: radial-gradient(circle at 20% 12%, #101216 0%, #090a0d 46%, #060709 100%);
    min-height: 100vh;
    overflow: hidden;
    font-family: 'Iowan Old Style', 'Palatino Linotype', Palatino, Georgia, serif;
    cursor: default;
    color: var(--text-primary);
  }

  /* =========================================================
     Layer 0: Orb Background Layer
     ========================================================= */
  .orb-layer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .orb-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .orb {
    overflow: visible;
    position: relative;
  }

  #orbCanvas {
    display: block;
  }

  /* pulseCanvas removed — fog cloud has no ring system */

  .orb-highlight {
    position: absolute;
    top: 12%;
    left: 23%;
    width: 20%;
    height: 13%;
    background: radial-gradient(ellipse, rgba(255,255,255,0.08) 0%, transparent 70%);
    border-radius: 50%;
    transform: rotate(-18deg);
    pointer-events: none;
    animation: highlightShift 12s ease-in-out infinite;
    opacity: 0.7;
  }

  .aura {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    border: 1px solid rgba(200, 211, 213, 0.05);
  }

  .aura-1 { animation: auraExpand 10s ease-in-out infinite; }
  .aura-2 { animation: auraExpand 10s ease-in-out infinite 3.2s; }
  .aura-3 { animation: auraExpand 10s ease-in-out infinite 6.4s; }

  @keyframes highlightShift {
    0%, 100% { opacity: 0.35; transform: rotate(-18deg) translateY(0); }
    50% { opacity: 0.12; transform: rotate(-12deg) translateY(5px); }
  }

  @keyframes auraExpand {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.06); opacity: 0.35; }
  }

  /* =========================================================
     Layer 1: Main Overlay
     ========================================================= */

  /* ---- Subtitle Area ---- */
  .subtitle-area {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: var(--input-bar-height);
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;
    padding: 0 24px 24px;
    pointer-events: none;
  }

  /* Scrim gradient behind subtitles for guaranteed readability over orb */
  .subtitle-area::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 45%;
    background: linear-gradient(to top, rgba(8, 9, 12, 0.35) 0%, rgba(8, 9, 12, 0.12) 50%, transparent 100%);
    pointer-events: none;
    z-index: -1;
  }

  .subtitle-stack {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: stretch;
    max-height: 40vh;
    overflow: hidden;
  }

  .subtitle-bubble {
    max-width: 78%;
    border-radius: 18px;
    padding: 10px 16px;
    font-size: 0.95rem;
    line-height: 1.5;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.4s ease, visibility 0.4s ease, transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    word-break: break-word;
    text-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
    transform: translateY(6px);
  }

  .subtitle-bubble.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
    animation: bubbleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  }

  @keyframes bubbleIn {
    0% {
      transform: scale(0.88);
      opacity: 0;
    }
    100% {
      transform: scale(1);
      opacity: 1;
    }
  }

  #subFae {
    align-self: flex-start;
    background: rgba(var(--heather-rgb), 0.22);
    border: 1px solid rgba(var(--heather-rgb), 0.25);
    -webkit-backdrop-filter: blur(20px) saturate(160%);
    backdrop-filter: blur(20px) saturate(160%);
    color: var(--text-primary);
    transform-origin: left center;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
  }

  #subUser {
    align-self: flex-end;
    background: rgba(255, 255, 255, 0.22);
    border: 1px solid rgba(255, 255, 255, 0.22);
    -webkit-backdrop-filter: blur(20px) saturate(160%);
    backdrop-filter: blur(20px) saturate(160%);
    color: var(--text-primary);
    transform-origin: right center;
    text-align: right;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
  }

  /* ---- Input Bar ---- */
  .input-bar-wrap {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 20;
    padding: 0 16px 16px;
    background: linear-gradient(to top, rgba(8, 9, 12, 0.88) 0%, rgba(8, 9, 12, 0.4) 60%, transparent 100%);
    animation: inputBarEntrance 0.6s cubic-bezier(0.22, 1, 0.36, 1) 0.2s both;
  }

  @keyframes inputBarEntrance {
    0% {
      opacity: 0;
      transform: translateY(12px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .input-bar-inner {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .input-row {
    display: flex;
    align-items: flex-end;
    gap: 10px;
    background: rgba(255, 255, 255, 0.07);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 22px;
    padding: 8px 8px 8px 12px;
    -webkit-backdrop-filter: blur(16px) saturate(140%);
    backdrop-filter: blur(16px) saturate(140%);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
  }

  .input-row:focus-within {
    border-color: rgba(var(--heather-rgb), 0.35);
    box-shadow: 0 0 0 1px rgba(var(--heather-rgb), 0.1), 0 4px 20px rgba(0, 0, 0, 0.25);
  }

  #listenToggle {
    flex-shrink: 0;
    width: 34px;
    height: 34px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.35s ease, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.35s ease;
    padding: 0;
    outline: none;
  }

  #listenToggle.active {
    background: #4ade80;
    box-shadow: 0 0 12px rgba(74, 222, 128, 0.4);
  }

  #listenToggle.inactive {
    background: rgba(255, 255, 255, 0.12);
    box-shadow: none;
  }

  #listenToggle:hover {
    transform: scale(1.08);
  }

  #listenToggle:active {
    transform: scale(0.93);
  }

  #listenToggle svg {
    width: 16px;
    height: 16px;
    display: block;
    transition: color 0.3s ease;
  }

  #listenToggle.active svg { color: #052416; }
  #listenToggle.inactive svg { color: rgba(255, 255, 255, 0.5); }

  #msgInput {
    flex: 1;
    background: transparent;
    border: none;
    outline: none;
    resize: none;
    color: var(--text-primary);
    font-family: 'Iowan Old Style', 'Palatino Linotype', Palatino, Georgia, serif;
    font-size: 0.95rem;
    line-height: 1.5;
    min-height: 34px;
    max-height: 120px;
    overflow-y: auto;
    padding: 7px 0;
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.15) transparent;
  }

  #msgInput::placeholder {
    color: rgba(255, 255, 255, 0.40);
    font-style: italic;
  }

  #msgInput::-webkit-scrollbar {
    width: 3px;
  }

  #msgInput::-webkit-scrollbar-track {
    background: transparent;
  }

  #msgInput::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.15);
    border-radius: 2px;
  }

  #sendBtn {
    flex-shrink: 0;
    width: 34px;
    height: 34px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(var(--heather-rgb), 0.28);
    border: 1px solid rgba(var(--heather-rgb), 0.22);
    transition: background 0.25s ease, opacity 0.25s ease, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.25s ease;
    padding: 0;
    outline: none;
  }

  #sendBtn:not(:disabled):hover {
    background: rgba(var(--heather-rgb), 0.45);
    box-shadow: 0 0 12px rgba(var(--heather-rgb), 0.2);
    transform: scale(1.08);
  }

  #sendBtn:not(:disabled):active {
    transform: scale(0.90);
    background: rgba(var(--heather-rgb), 0.55);
  }

  #sendBtn:disabled {
    opacity: 0.30;
    cursor: default;
  }

  #sendBtn svg {
    width: 16px;
    height: 16px;
    display: block;
    color: rgba(255, 255, 255, 0.85);
    transition: transform 0.2s ease;
  }

  #sendBtn:not(:disabled):hover svg {
    transform: translateY(-1px);
  }

  .action-pills {
    display: flex;
    justify-content: center;
    gap: 8px;
  }

  .action-pill {
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.09);
    border-radius: 20px;
    padding: 5px 16px;
    font-family: 'Iowan Old Style', 'Palatino Linotype', Palatino, Georgia, serif;
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.65);
    cursor: pointer;
    letter-spacing: 0.04em;
    transition: background 0.25s ease, color 0.25s ease, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.25s ease, outline-color 0.15s ease;
  }

  .action-pill:hover {
    background: rgba(255, 255, 255, 0.12);
    border-color: rgba(255, 255, 255, 0.16);
    color: rgba(255, 255, 255, 0.88);
    transform: translateY(-1px);
  }

  .action-pill:active {
    transform: translateY(0) scale(0.97);
    background: rgba(255, 255, 255, 0.15);
  }

  .action-pill:focus-visible,
  #listenToggle:focus-visible,
  #sendBtn:focus-visible {
    outline: 2px solid rgba(180, 168, 196, 0.6);
    outline-offset: 2px;
  }

  /* =========================================================
     Progress Bar (model loading / download)
     ========================================================= */
  .progress-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 30;
    display: none;
    flex-direction: column;
    align-items: center;
    padding: 12px 24px 8px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s ease;
  }

  .progress-bar.visible {
    display: flex;
    opacity: 1;
  }

  .progress-bar-track {
    width: 100%;
    max-width: 280px;
    height: 3px;
    background: rgba(255, 255, 255, 0.08);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-bar-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, rgba(var(--heather-rgb), 0.5), rgba(var(--heather-rgb), 0.85));
    border-radius: 2px;
    transition: width 0.5s cubic-bezier(0.22, 1, 0.36, 1);
    box-shadow: 0 0 8px rgba(var(--heather-rgb), 0.3);
  }

  .progress-bar-label {
    margin-top: 6px;
    font-size: 0.72rem;
    color: rgba(255, 255, 255, 0.48);
    letter-spacing: 0.04em;
    text-align: center;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }

  /* =========================================================
     Window Mode: Collapsed — tiny orb only
     ========================================================= */
  body[data-window-mode="collapsed"] .subtitle-area,
  body[data-window-mode="collapsed"] .input-bar-wrap,
  body[data-window-mode="collapsed"] .progress-bar {
    display: none !important;
  }

  body[data-window-mode="collapsed"] .orb-layer {
    cursor: pointer;
  }

  /* =========================================================
     Enhanced Listen Toggle — prominent glow when active
     ========================================================= */
  #listenToggle.active {
    background: #4ade80;
    box-shadow: 0 0 12px rgba(74, 222, 128, 0.4), 0 0 24px rgba(74, 222, 128, 0.15);
    animation: listenPulse 2s ease-in-out infinite;
  }

  @keyframes listenPulse {
    0%, 100% { box-shadow: 0 0 12px rgba(74, 222, 128, 0.4), 0 0 24px rgba(74, 222, 128, 0.15); }
    50% { box-shadow: 0 0 16px rgba(74, 222, 128, 0.6), 0 0 32px rgba(74, 222, 128, 0.25); }
  }

  /* Send feedback — brief scale pulse on message dispatch */
  @keyframes sendPulse {
    0% { transform: scale(1); }
    30% { transform: scale(0.85); }
    60% { transform: scale(1.08); }
    100% { transform: scale(1); }
  }

  #sendBtn.sent {
    animation: sendPulse 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  /* =========================================================
     Reduced Motion — disable non-essential animations
     ========================================================= */
  @media (prefers-reduced-motion: reduce) {
    .input-bar-wrap {
      animation: none;
    }
    .subtitle-bubble {
      transition: opacity 0.2s ease, visibility 0.2s ease;
      transform: none !important;
    }
    .subtitle-bubble.visible {
      animation: none;
      transform: none !important;
    }
    .action-pill,
    #listenToggle,
    #sendBtn {
      transition-duration: 0.1s;
    }
    .action-pill:hover,
    #sendBtn:not(:disabled):hover {
      transform: none;
    }
    #listenToggle.active {
      animation: none;
    }
    #sendBtn.sent {
      animation: none;
    }
    .orb-highlight {
      animation: none;
    }
    .aura-1, .aura-2, .aura-3 {
      animation: none;
    }
  }

  /* =========================================================
     Selection Color
     ========================================================= */
  ::selection {
    background: rgba(var(--heather-rgb), 0.35);
    color: #fff;
  }

</style>
</head>
<body>

  <!-- =========================================================
       Layer 0: Orb Background Layer
       ========================================================= -->
  <div class="orb-layer" id="scene">
    <div class="aura aura-1" id="aura1"></div>
    <div class="aura aura-2" id="aura2"></div>
    <div class="aura aura-3" id="aura3"></div>

    <div class="orb-wrapper" id="orbWrapper">
      <div class="orb" id="orbContainer">
        <canvas id="orbCanvas"></canvas>
      </div>
      <div class="orb-highlight"></div>
    </div>
  </div>

  <!-- =========================================================
       Progress Bar (model loading)
       ========================================================= -->
  <div class="progress-bar" id="progressBar">
    <div class="progress-bar-track">
      <div class="progress-bar-fill" id="progressFill"></div>
    </div>
    <span class="progress-bar-label" id="progressLabel"></span>
  </div>

  <!-- =========================================================
       Layer 1: Subtitle Area
       ========================================================= -->
  <div class="subtitle-area">
    <div class="subtitle-stack">
      <div class="subtitle-bubble" id="subFae" aria-live="polite"></div>
      <div class="subtitle-bubble" id="subUser" aria-live="polite"></div>
    </div>
  </div>

  <!-- =========================================================
       Layer 1: Input Bar
       ========================================================= -->
  <div class="input-bar-wrap">
    <div class="input-bar-inner">
      <div class="input-row">
        <!-- Listen Toggle -->
        <button id="listenToggle" class="active" aria-label="Toggle listening">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
            <line x1="12" y1="19" x2="12" y2="23"/>
            <line x1="8" y1="23" x2="16" y2="23"/>
          </svg>
        </button>

        <!-- Message Input -->
        <textarea
          id="msgInput"
          rows="1"
          placeholder="Message Fae..."
          aria-label="Message input"
        ></textarea>

        <!-- Send Button -->
        <button id="sendBtn" disabled aria-label="Send message">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="19" x2="12" y2="5"/>
            <polyline points="5 12 12 5 19 12"/>
          </svg>
        </button>
      </div>

      <!-- Action Pills -->
      <div class="action-pills">
        <button class="action-pill" id="showConvBtn">Show Discussions</button>
        <button class="action-pill" id="showCanvasBtn">Show Canvas</button>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   Fae Conversation — Combined Animation + Conversation Engine
   ========================================================= */

/* ---------------------------------------------------------
   1. HSL Color Utilities
   --------------------------------------------------------- */
function hexToRgb(hex) {
  var c = hex.replace("#", "");
  var n = parseInt(c, 16);
  return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
}

function hexToHsl(hex) {
  var c = hexToRgb(hex);
  var r = c.r / 255, g = c.g / 255, b = c.b / 255;
  var mx = Math.max(r, g, b), mn = Math.min(r, g, b);
  var h = 0, s = 0, l = (mx + mn) / 2;
  if (mx !== mn) {
    var d = mx - mn;
    s = l > 0.5 ? d / (2 - mx - mn) : d / (mx + mn);
    if (mx === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
    else if (mx === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
  }
  return { h: h * 360, s: s * 100, l: l * 100 };
}

function hslToRgb(h, s, l) {
  h = ((h % 360) + 360) % 360;
  var S = s / 100, L = l / 100;
  var c = (1 - Math.abs(2 * L - 1)) * S;
  var x = c * (1 - Math.abs((h / 60) % 2 - 1));
  var m = L - c / 2;
  var r = 0, g = 0, b = 0;
  if (h < 60) { r = c; g = x; }
  else if (h < 120) { r = x; g = c; }
  else if (h < 180) { g = c; b = x; }
  else if (h < 240) { g = x; b = c; }
  else if (h < 300) { r = x; b = c; }
  else { r = c; b = x; }
  return {
    r: Math.round((r + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255)
  };
}

function lerpHsl(from, to, t) {
  var dh = to.h - from.h;
  if (dh > 180) dh -= 360;
  if (dh < -180) dh += 360;
  return {
    h: from.h + dh * t,
    s: from.s + (to.s - from.s) * t,
    l: from.l + (to.l - from.l) * t
  };
}

function hslToHex(h, s, l) {
  var rgb = hslToRgb(h, s, l);
  return "#" + ((1 << 24) | (rgb.r << 16) | (rgb.g << 8) | rgb.b).toString(16).slice(1);
}

function lerpColorHex(fromHex, toHex, t) {
  var a = hexToHsl(fromHex);
  var b = hexToHsl(toHex);
  var c = lerpHsl(a, b, t);
  return hslToHex(c.h, c.s, c.l);
}

function lerpN(a, b, t) { return a + (b - a) * t; }

/* ---------------------------------------------------------
   2. Inline 2D Simplex Noise
   --------------------------------------------------------- */
var SimplexNoise = (function() {
  var F2 = 0.5 * (Math.sqrt(3) - 1);
  var G2 = (3 - Math.sqrt(3)) / 6;
  var grad3 = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];

  function SimplexNoise(seed) {
    this.perm = new Uint8Array(512);
    this.permMod8 = new Uint8Array(512);
    var p = new Uint8Array(256);
    var s = seed || Math.random() * 2147483647;
    for (var i = 0; i < 256; i++) p[i] = i;
    for (var i = 255; i > 0; i--) {
      s = (s * 16807 + 0) % 2147483647;
      var j = s % (i + 1);
      var tmp = p[i]; p[i] = p[j]; p[j] = tmp;
    }
    for (var i = 0; i < 512; i++) {
      this.perm[i] = p[i & 255];
      this.permMod8[i] = this.perm[i] % 8;
    }
  }

  SimplexNoise.prototype.noise2D = function(xin, yin) {
    var s = (xin + yin) * F2;
    var i = Math.floor(xin + s);
    var j = Math.floor(yin + s);
    var t = (i + j) * G2;
    var X0 = i - t, Y0 = j - t;
    var x0 = xin - X0, y0 = yin - Y0;
    var i1, j1;
    if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
    var x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
    var ii = i & 255, jj = j & 255;
    var n0 = 0, n1 = 0, n2 = 0;
    var t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 >= 0) {
      t0 *= t0;
      var gi0 = this.permMod8[ii + this.perm[jj]];
      n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0);
    }
    var t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 >= 0) {
      t1 *= t1;
      var gi1 = this.permMod8[ii + i1 + this.perm[jj + j1]];
      n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1);
    }
    var t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 >= 0) {
      t2 *= t2;
      var gi2 = this.permMod8[ii + 1 + this.perm[jj + 1]];
      n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2);
    }
    return 70 * (n0 + n1 + n2);
  };

  return SimplexNoise;
})();

var noise = new SimplexNoise(42);

/* ---------------------------------------------------------
   3. Palettes, Modes, Overrides
   --------------------------------------------------------- */
var PALETTE = {
  heatherMist: "#B4A8C4",
  glenGreen: "#5F7F6F",
  lochGreyGreen: "#7A9B8E",
  autumnBracken: "#A67B5B",
  silverMist: "#C8D3D5",
  rowanBerry: "#8B4653",
  mossStone: "#4A5D52",
  dawnLight: "#E8DED2",
  peatEarth: "#3D3630"
};

var MODES = {
  idle: {
    base: [PALETTE.heatherMist, PALETTE.lochGreyGreen, PALETTE.silverMist],
    fogIntensity: 1.0,
    starIntensity: 1.0,
    morphIntensity: 1.0,
    morphSpeedMul: 1.0
  },
  listening: {
    base: [PALETTE.glenGreen, PALETTE.lochGreyGreen, PALETTE.silverMist],
    fogIntensity: 1.1,
    starIntensity: 1.3,
    morphIntensity: 1.2,
    morphSpeedMul: 1.3
  },
  thinking: {
    base: [PALETTE.heatherMist, PALETTE.rowanBerry, PALETTE.lochGreyGreen],
    fogIntensity: 1.3,
    starIntensity: 0.7,
    morphIntensity: 0.8,
    morphSpeedMul: 0.6
  },
  speaking: {
    base: [PALETTE.autumnBracken, PALETTE.rowanBerry, PALETTE.dawnLight],
    fogIntensity: 1.2,
    starIntensity: 1.5,
    morphIntensity: 1.4,
    morphSpeedMul: 1.1
  }
};

var PALETTE_OVERRIDES = {
  "heather-mist": [PALETTE.heatherMist, PALETTE.lochGreyGreen, PALETTE.silverMist],
  "glen-green": [PALETTE.glenGreen, PALETTE.lochGreyGreen, PALETTE.mossStone],
  "loch-grey-green": [PALETTE.lochGreyGreen, PALETTE.silverMist, PALETTE.glenGreen],
  "autumn-bracken": [PALETTE.autumnBracken, PALETTE.dawnLight, PALETTE.rowanBerry],
  "silver-mist": [PALETTE.silverMist, PALETTE.heatherMist, PALETTE.dawnLight],
  "rowan-berry": [PALETTE.rowanBerry, PALETTE.autumnBracken, PALETTE.peatEarth],
  "moss-stone": [PALETTE.mossStone, PALETTE.glenGreen, PALETTE.peatEarth],
  "dawn-light": [PALETTE.dawnLight, PALETTE.silverMist, PALETTE.autumnBracken],
  "peat-earth": [PALETTE.peatEarth, PALETTE.mossStone, PALETTE.dawnLight]
};

/* ---------------------------------------------------------
   4. Feelings System
   --------------------------------------------------------- */
/* Each feeling maps to a distinct fog-cloud personality (from Round 3 showcase).
   neutral  → Warm Whisper    (intimate, cozy, gentle stars)
   calm     → Gentle Fog      (soft, sparse, serene)
   curiosity→ Drifting Nebula  (active morphing, rolling wisps)
   warmth   → Warm Whisper+    (warm variant, slightly thicker)
   concern  → Dense Fog       (thick, mysterious, shimmer)
   delight  → Cosmic Mist     (full atmosphere, bright stars)
   focus    → Rolling Mist    (concentrated, many wisps)
   playful  → Aurora Dream    (most alive, dancing, asymmetric) */
var FEELINGS = {
  neutral: {
    hueShift: 0, speedScale: 1.0, breathAmplitude: 0.012,
    fogDensity: 0.6, morphAmplitude: 0.06, morphFreq: 2, morphSpeed: 0.18,
    shimmer: 0.03, asymmetry: 0.04,
    starAlpha: 0.55, outerAlpha: 0.35,
    wispSize: 0.25, wispAlpha: 0.05,
    blobAlpha: 0.14, innerGlow: 0.2
  },
  calm: {
    hueShift: -5, speedScale: 0.7, breathAmplitude: 0.02,
    fogDensity: 0.7, morphAmplitude: 0.04, morphFreq: 2, morphSpeed: 0.12,
    shimmer: 0.02, asymmetry: 0.03,
    starAlpha: 0.4, outerAlpha: 0.25,
    wispSize: 0.3, wispAlpha: 0.06,
    blobAlpha: 0.12, innerGlow: 0.15
  },
  curiosity: {
    hueShift: 15, speedScale: 1.15, breathAmplitude: 0.014,
    fogDensity: 0.65, morphAmplitude: 0.1, morphFreq: 3, morphSpeed: 0.3,
    shimmer: 0.06, asymmetry: 0.1,
    starAlpha: 0.55, outerAlpha: 0.3,
    wispSize: 0.38, wispAlpha: 0.07,
    blobAlpha: 0.12, innerGlow: 0.2
  },
  warmth: {
    hueShift: 25, speedScale: 0.9, breathAmplitude: 0.016,
    fogDensity: 0.65, morphAmplitude: 0.06, morphFreq: 2, morphSpeed: 0.18,
    shimmer: 0.03, asymmetry: 0.04,
    starAlpha: 0.5, outerAlpha: 0.35,
    wispSize: 0.25, wispAlpha: 0.05,
    blobAlpha: 0.15, innerGlow: 0.25
  },
  concern: {
    hueShift: -10, speedScale: 0.85, breathAmplitude: 0.008,
    fogDensity: 0.85, morphAmplitude: 0.05, morphFreq: 2, morphSpeed: 0.15,
    shimmer: 0.06, asymmetry: 0.06,
    starAlpha: 0.35, outerAlpha: 0.2,
    wispSize: 0.4, wispAlpha: 0.08,
    blobAlpha: 0.14, innerGlow: 0.12
  },
  delight: {
    hueShift: 10, speedScale: 1.3, breathAmplitude: 0.018,
    fogDensity: 0.55, morphAmplitude: 0.09, morphFreq: 3, morphSpeed: 0.28,
    shimmer: 0.05, asymmetry: 0.08,
    starAlpha: 0.65, outerAlpha: 0.35,
    wispSize: 0.35, wispAlpha: 0.07,
    blobAlpha: 0.13, innerGlow: 0.22
  },
  focus: {
    hueShift: 5, speedScale: 1.1, breathAmplitude: 0.01,
    fogDensity: 0.75, morphAmplitude: 0.03, morphFreq: 2, morphSpeed: 0.1,
    shimmer: 0.02, asymmetry: 0.02,
    starAlpha: 0.4, outerAlpha: 0.2,
    wispSize: 0.35, wispAlpha: 0.07,
    blobAlpha: 0.13, innerGlow: 0.18
  },
  playful: {
    hueShift: 20, speedScale: 1.2, breathAmplitude: 0.015,
    fogDensity: 0.6, morphAmplitude: 0.12, morphFreq: 3, morphSpeed: 0.35,
    shimmer: 0.08, asymmetry: 0.12,
    starAlpha: 0.6, outerAlpha: 0.35,
    wispSize: 0.38, wispAlpha: 0.07,
    blobAlpha: 0.12, innerGlow: 0.2
  }
};

/* ---------------------------------------------------------
   5. State
   --------------------------------------------------------- */
var mode = "idle";
var paletteOverride = "mode-default";
var currentFeeling = "neutral";
var urgencyLevel = 0;
var pointer = { x: 0.5, y: 0.5, influence: 0 };
var reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

/* Flash state */
var flashState = { active: false, type: "error", startTime: 0, duration: 1000 };

/* Anticipation state */
var anticipation = { active: false, type: "none", startTime: 0, duration: 300, scale: 1.0 };

/* Transition engine state */
var TRANSITION_DURATION = 500;
var transition = {
  active: false,
  startTime: 0,
  from: null,
  to: null,
  progress: 1
};

/* ---------------------------------------------------------
   6. Canvas Elements and Sizing
   --------------------------------------------------------- */
var orbCanvas = document.getElementById("orbCanvas");
var orbCtx = orbCanvas.getContext("2d");
var orbWrapper = document.getElementById("orbWrapper");
var orbContainer = document.getElementById("orbContainer");
var sceneEl = document.getElementById("scene");
var aura1 = document.getElementById("aura1");
var aura2 = document.getElementById("aura2");
var aura3 = document.getElementById("aura3");

/* Noise grain overlay canvas */
var grainCanvas = document.createElement("canvas");
var grainCtx = grainCanvas.getContext("2d");
var grainPattern = null;
var grainTileSize = 128;

/* Sizing state */
var orbDiameter = 320;
var orbRadius = 160;
var canvasSize = 640;
var dpr = window.devicePixelRatio || 1;

function recalcSize() {
  var vw = window.innerWidth;
  var vh = window.innerHeight;
  var minDim = Math.min(vw, vh);
  orbDiameter = Math.round(minDim * 0.72);
  orbRadius = orbDiameter / 2;
  dpr = window.devicePixelRatio || 1;
  /* Canvas oversized to allow fog/stars to render beyond the orb edge */
  canvasSize = Math.round(orbDiameter * 1.4 * dpr);
  var canvasCss = Math.round(orbDiameter * 1.4);

  orbCanvas.width = canvasSize;
  orbCanvas.height = canvasSize;
  orbCanvas.style.width = canvasCss + "px";
  orbCanvas.style.height = canvasCss + "px";

  orbContainer.style.width = canvasCss + "px";
  orbContainer.style.height = canvasCss + "px";

  orbWrapper.style.width = canvasCss + "px";
  orbWrapper.style.height = canvasCss + "px";

  /* Aura sizes relative to orb */
  var a1 = Math.round(orbDiameter * 1.19);
  var a2 = Math.round(orbDiameter * 1.41);
  var a3 = Math.round(orbDiameter * 1.63);
  aura1.style.width = a1 + "px"; aura1.style.height = a1 + "px";
  aura2.style.width = a2 + "px"; aura2.style.height = a2 + "px";
  aura3.style.width = a3 + "px"; aura3.style.height = a3 + "px";

  /* Grain uses a fixed low-res tile */
  if (grainCanvas.width !== grainTileSize || grainCanvas.height !== grainTileSize) {
    grainCanvas.width = grainTileSize;
    grainCanvas.height = grainTileSize;
  }
  regenerateGrain();
}

recalcSize();

if (typeof ResizeObserver !== "undefined") {
  new ResizeObserver(function() { recalcSize(); }).observe(document.body);
} else {
  window.addEventListener("resize", recalcSize);
}

/* ---------------------------------------------------------
   7. Snapshot / Transition Engine
   --------------------------------------------------------- */
function snapshotState() {
  var pal = activePalette();
  var m = MODES[mode];
  var f = FEELINGS[currentFeeling];
  return {
    colors: pal.slice(),
    hueShift: f.hueShift,
    speedScale: f.speedScale,
    breathAmplitude: f.breathAmplitude,
    fogDensity: f.fogDensity * (m.fogIntensity || 1.0),
    morphAmplitude: f.morphAmplitude * (m.morphIntensity || 1.0),
    morphFreq: f.morphFreq,
    morphSpeed: f.morphSpeed * (m.morphSpeedMul || 1.0),
    shimmer: f.shimmer,
    asymmetry: f.asymmetry,
    starAlpha: f.starAlpha * (m.starIntensity || 1.0),
    outerAlpha: f.outerAlpha,
    wispSize: f.wispSize,
    wispAlpha: f.wispAlpha,
    blobAlpha: f.blobAlpha,
    innerGlow: f.innerGlow
  };
}

function lerpSnapshot(a, b, t) {
  var colors = [];
  var len = Math.max(a.colors.length, b.colors.length);
  for (var i = 0; i < len; i++) {
    var ca = a.colors[i % a.colors.length];
    var cb = b.colors[i % b.colors.length];
    colors.push(lerpColorHex(ca, cb, t));
  }
  return {
    colors: colors,
    hueShift: lerpN(a.hueShift, b.hueShift, t),
    speedScale: lerpN(a.speedScale, b.speedScale, t),
    breathAmplitude: lerpN(a.breathAmplitude, b.breathAmplitude, t),
    fogDensity: lerpN(a.fogDensity, b.fogDensity, t),
    morphAmplitude: lerpN(a.morphAmplitude, b.morphAmplitude, t),
    morphFreq: lerpN(a.morphFreq, b.morphFreq, t),
    morphSpeed: lerpN(a.morphSpeed, b.morphSpeed, t),
    shimmer: lerpN(a.shimmer, b.shimmer, t),
    asymmetry: lerpN(a.asymmetry, b.asymmetry, t),
    starAlpha: lerpN(a.starAlpha, b.starAlpha, t),
    outerAlpha: lerpN(a.outerAlpha, b.outerAlpha, t),
    wispSize: lerpN(a.wispSize, b.wispSize, t),
    wispAlpha: lerpN(a.wispAlpha, b.wispAlpha, t),
    blobAlpha: lerpN(a.blobAlpha, b.blobAlpha, t),
    innerGlow: lerpN(a.innerGlow, b.innerGlow, t)
  };
}

function springEase(t) {
  /* Critically-damped spring approximation */
  return 1 - Math.exp(-6 * t) * Math.cos(t * 2.5);
}

function captureTransitionFrom(nowMs) {
  if (transition.active) {
    transition.from = lerpSnapshot(transition.from, transition.to, springEase(transition.progress));
  } else {
    transition.from = snapshotState();
  }
  transition.startTime = nowMs || performance.now();
}

function completeTransition(nowMs) {
  transition.to = snapshotState();
  transition.startTime = nowMs || performance.now();
  transition.active = true;
  transition.progress = 0;
}

function currentSnapshot(nowMs) {
  if (transition.active) {
    var elapsed = nowMs - transition.startTime;
    transition.progress = Math.min(elapsed / TRANSITION_DURATION, 1);
    var t = springEase(transition.progress);
    if (transition.progress >= 1) {
      transition.active = false;
    }
    return lerpSnapshot(transition.from, transition.to, t);
  }
  return snapshotState();
}

/* ---------------------------------------------------------
   8. Helpers
   --------------------------------------------------------- */
function normalizePaletteKey(value) {
  return String(value || "")
    .trim()
    .toLowerCase()
    .replace(/_/g, "-")
    .replace(/\s+/g, "-");
}

function activePalette() {
  if (paletteOverride !== "mode-default" && PALETTE_OVERRIDES[paletteOverride]) {
    return PALETTE_OVERRIDES[paletteOverride];
  }
  return MODES[mode].base;
}

/* ---------------------------------------------------------
   9. Anticipation Triggers
   --------------------------------------------------------- */
function triggerAnticipation(type, nowMs) {
  anticipation.active = true;
  anticipation.type = type;
  anticipation.startTime = nowMs;
  if (type === "contract") {
    anticipation.duration = 180;
  } else if (type === "pause") {
    anticipation.duration = 220;
  } else if (type === "burst") {
    anticipation.duration = 280;
  }
}

function getAnticipationScale(nowMs) {
  if (!anticipation.active) return 1.0;
  var elapsed = nowMs - anticipation.startTime;
  var t = Math.min(elapsed / anticipation.duration, 1);
  if (t >= 1) {
    anticipation.active = false;
    return 1.0;
  }
  var eased = Math.sin(t * Math.PI);
  if (anticipation.type === "contract") {
    return 1.0 - 0.04 * eased;
  } else if (anticipation.type === "pause") {
    return 1.0 - 0.02 * eased;
  } else if (anticipation.type === "burst") {
    return 1.0 + 0.06 * eased;
  }
  return 1.0;
}

/* ---------------------------------------------------------
   10. Window API — Orb Controls
   --------------------------------------------------------- */
window.setOrbMode = function setOrbMode(next) {
  if (!MODES[next]) return;
  var prev = mode;
  var nowMs = performance.now();
  captureTransitionFrom(nowMs);
  mode = next;
  if (next === "thinking" && prev !== "thinking") {
    triggerAnticipation("contract", nowMs);
  } else if (next === "listening" && prev !== "listening") {
    triggerAnticipation("pause", nowMs);
  } else if (next === "speaking" && prev !== "speaking") {
    triggerAnticipation("burst", nowMs);
  }
  completeTransition(nowMs);
};

window.setOrbPalette = function setOrbPalette(next) {
  var key = normalizePaletteKey(next);
  if (!key || key === "mode-default" || key === "default") {
    var nowMs = performance.now();
    captureTransitionFrom(nowMs);
    paletteOverride = "mode-default";
    completeTransition(nowMs);
    return;
  }
  if (!PALETTE_OVERRIDES[key]) return;
  var nowMs = performance.now();
  captureTransitionFrom(nowMs);
  paletteOverride = key;
  completeTransition(nowMs);
};

window.clearOrbPalette = function clearOrbPalette() {
  var nowMs = performance.now();
  captureTransitionFrom(nowMs);
  paletteOverride = "mode-default";
  completeTransition(nowMs);
};

window.setOrbFeeling = function setOrbFeeling(feeling) {
  if (!FEELINGS[feeling]) return;
  var nowMs = performance.now();
  captureTransitionFrom(nowMs);
  currentFeeling = feeling;
  completeTransition(nowMs);
};

window.setOrbUrgency = function setOrbUrgency(level) {
  urgencyLevel = Math.max(0, Math.min(1, level));
};

window.setOrbFlash = function setOrbFlash(type) {
  if (type !== "error" && type !== "success") return;
  flashState.active = true;
  flashState.type = type;
  flashState.startTime = performance.now();
  flashState.duration = 1000;
};

/* ---------------------------------------------------------
   11. Fog Cloud Elements: Stars, Blobs, Wisps
   --------------------------------------------------------- */
var FOG_LAYERS = 6;
var BLOB_COUNT = reducedMotion ? 6 : 14;
var STAR_COUNT = reducedMotion ? 0 : 100;
var OUTER_STAR_COUNT = reducedMotion ? 0 : 20;
var WISP_COUNT = reducedMotion ? 0 : 8;

/* Blobs — internal flowing fog motion */
var blobs = [];
for (var i = 0; i < 14; i++) {
  blobs.push({
    orbitRadius: 0.08 + (i / 14) * 0.38,
    phaseOffset: (i * 2.399) % (Math.PI * 2),
    speedVariance: 0.7 + Math.random() * 0.6,
    noiseSeed: i * 137.5,
    colorIdx: i % 3
  });
}

/* Wisps — smooth round fog puffs at boundary */
var wisps = [];
for (var i = 0; i < 8; i++) {
  wisps.push({
    baseAngle: (i / 8) * Math.PI * 2 + (Math.random() - 0.5) * 0.8,
    dist: 0.6 + Math.random() * 0.35,
    sizeBase: 0.7 + Math.random() * 0.6,
    driftSpeed: 0.03 + Math.random() * 0.08,
    noiseSeed: i * 345,
    alphaBase: 0.7 + Math.random() * 0.6,
    colorIdx: i % 3
  });
}

/* ---------------------------------------------------------
   12. Star System — tiny twinkling points, not big sparkles
   --------------------------------------------------------- */
function spawnStar(nowSec, outer) {
  var angle = Math.random() * Math.PI * 2;
  var dist = outer
    ? (0.7 + Math.random() * 0.35)
    : (0.04 + Math.random() * 0.62);
  var isBright = Math.random() < 0.06;
  return {
    angle: angle,
    dist: dist,
    speed: 0.015 + Math.random() * 0.12,
    size: isBright ? (0.8 + Math.random() * 0.5) : (0.2 + Math.random() * 0.7),
    born: nowSec,
    lifespan: 3 + Math.random() * 8,
    noiseSeed: Math.random() * 1000,
    colorIdx: Math.floor(Math.random() * 3),
    bright: isBright,
    twinkleRate: 1.5 + Math.random() * 4,
    twinklePhase: Math.random() * Math.PI * 2,
    outer: outer || false
  };
}

var stars = [];
for (var i = 0; i < STAR_COUNT; i++) {
  var s = spawnStar(0, false);
  s.born = -(Math.random() * s.lifespan);
  stars.push(s);
}
for (var i = 0; i < OUTER_STAR_COUNT; i++) {
  var s = spawnStar(0, true);
  s.born = -(Math.random() * s.lifespan);
  stars.push(s);
}

/* ---------------------------------------------------------
   13. Noise Grain Generator
   --------------------------------------------------------- */
function regenerateGrain() {
  var w = grainCanvas.width;
  var h = grainCanvas.height;
  if (w === 0 || h === 0) return;
  var imgData = grainCtx.createImageData(w, h);
  var data = imgData.data;
  for (var i = 0; i < data.length; i += 4) {
    var v = Math.random() * 255;
    data[i] = v;
    data[i + 1] = v;
    data[i + 2] = v;
    data[i + 3] = 255;
  }
  grainCtx.putImageData(imgData, 0, 0);
  grainPattern = orbCtx.createPattern(grainCanvas, "repeat");
}

/* ---------------------------------------------------------
   14. Fog Cloud Drawing — Warm Whisper base, mood-morphing
   --------------------------------------------------------- */
function drawOrb(nowSec, nowMs, snap) {
  var W = orbCanvas.width;
  var H = orbCanvas.height;
  var CX = W / 2;
  var CY = H / 2;
  /* Fog cloud base radius (tight cloud style) */
  var R = W / 2 * 0.42;

  var colors = snap.colors.map(hexToRgb);
  orbCtx.clearRect(0, 0, W, H);

  /* Urgency modifiers */
  var urg = urgencyLevel;

  /* Breathing */
  var breathAmp = snap.breathAmplitude;
  var throb = 1 + Math.sin(nowSec * 0.42) * breathAmp;

  /* Anticipation scale */
  var antScale = getAnticipationScale(nowMs);
  throb *= antScale;

  /* Hue shift */
  var hueShift = snap.hueShift;
  function shiftColor(c) {
    if (hueShift === 0) return c;
    var hsl = hexToHsl("#" + ((1 << 24) | (c.r << 16) | (c.g << 8) | c.b).toString(16).slice(1));
    var shifted = hslToRgb(hsl.h + hueShift, hsl.s, hsl.l);
    return shifted;
  }
  var sColors = colors.map(shiftColor);

  /* Organic shape: morph displacement for fog center drift */
  var driftX = noise.noise2D(nowSec * 0.08, 0) * R * 0.06;
  var driftY = noise.noise2D(0, nowSec * 0.08 + 50) * R * 0.06;

  /* Pointer drift */
  var pDriftX = (pointer.x - 0.5) * 30 * dpr * pointer.influence;
  var pDriftY = (pointer.y - 0.5) * 30 * dpr * pointer.influence;
  driftX += pDriftX;
  driftY += pDriftY;

  /* Morph displacement field for the fog boundary shape */
  var MSEG = 32;
  var morphPoints = [];
  var amp = snap.morphAmplitude * (1 + urg * 0.3);
  var mFreq = snap.morphFreq;
  var mSpeed = snap.morphSpeed * snap.speedScale;
  var shimmerVal = snap.shimmer;
  var asymVal = snap.asymmetry;
  if (reducedMotion) { amp = Math.min(amp, 0.02); mSpeed = 0.02; shimmerVal = 0; }
  for (var mi = 0; mi < MSEG; mi++) {
    var angle = (mi / MSEG) * Math.PI * 2;
    var n1 = noise.noise2D(Math.cos(angle) * mFreq + nowSec * mSpeed,
                           Math.sin(angle) * mFreq + nowSec * mSpeed * 0.7);
    var n2 = noise.noise2D(Math.cos(angle) * (mFreq * 0.5) + nowSec * mSpeed * 0.3 + 100,
                           Math.sin(angle) * (mFreq * 0.5) + nowSec * mSpeed * 0.2 + 100);
    var shimN = shimmerVal > 0 ? noise.noise2D(angle * 8, nowSec * 3) * shimmerVal * 0.02 : 0;
    var asymF = 1 + asymVal * Math.sin(angle + nowSec * 0.3);
    var disp = n1 * amp * 0.7 + n2 * amp * 0.3 + shimN;
    morphPoints.push((1 + disp) * asymF);
  }

  /* Helper: get morph scale at any angle */
  function getMorphAt(a) {
    var t = ((a % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
    var idx = (t / (Math.PI * 2)) * MSEG;
    var i0 = Math.floor(idx) % MSEG;
    var i1 = (i0 + 1) % MSEG;
    var frac = idx - Math.floor(idx);
    return morphPoints[i0] * (1 - frac) + morphPoints[i1] * frac;
  }

  orbCtx.save();
  orbCtx.translate(CX, CY);
  orbCtx.scale(throb, throb);
  orbCtx.translate(-CX, -CY);

  /* ---- SMOOTH ROUND WISPS (soft fog puffs at boundary) ---- */
  if (!reducedMotion) {
    var wAlphaMul = snap.wispAlpha;
    var wSizeMul = snap.wispSize;
    for (var wi = 0; wi < WISP_COUNT; wi++) {
      var wisp = wisps[wi];
      var wAngle = wisp.baseAngle + noise.noise2D(wisp.noiseSeed + nowSec * wisp.driftSpeed, wi * 3) * 0.6;
      var wDist = wisp.dist * R * getMorphAt(wAngle);
      var wx = CX + Math.cos(wAngle) * wDist + driftX * 0.5;
      var wy = CY + Math.sin(wAngle) * wDist + driftY * 0.5;
      var wR = wSizeMul * wisp.sizeBase * R;
      var wPulse = 1 + Math.sin(nowSec * 0.3 + wi * 1.5) * 0.15;
      wR *= wPulse;
      var wa = wAlphaMul * wisp.alphaBase;
      var c = sColors[wisp.colorIdx % sColors.length];
      var wGrad = orbCtx.createRadialGradient(wx, wy, 0, wx, wy, wR);
      wGrad.addColorStop(0, "rgba(" + c.r + "," + c.g + "," + c.b + "," + wa + ")");
      wGrad.addColorStop(0.5, "rgba(" + c.r + "," + c.g + "," + c.b + "," + (wa * 0.4) + ")");
      wGrad.addColorStop(1, "rgba(" + c.r + "," + c.g + "," + c.b + ",0)");
      orbCtx.fillStyle = wGrad;
      orbCtx.beginPath();
      orbCtx.arc(wx, wy, wR, 0, Math.PI * 2);
      orbCtx.fill();
    }
  }

  /* ---- FOG BODY (layered soft radial gradients, organically displaced) ---- */
  var fogD = snap.fogDensity;
  for (var layer = 0; layer < FOG_LAYERS; layer++) {
    var layerT = layer / (FOG_LAYERS - 1);
    var layerR = R * (0.25 + layerT * 0.8);
    var lAngle = (layer / FOG_LAYERS) * Math.PI * 2;
    var lMorph = getMorphAt(lAngle + nowSec * 0.05);
    var lx = CX + noise.noise2D(layer * 12 + nowSec * 0.06, 0) * R * 0.1 * lMorph + driftX;
    var ly = CY + noise.noise2D(0, layer * 12 + nowSec * 0.06) * R * 0.1 * lMorph + driftY;
    var layerAlpha = fogD * (0.2 - layerT * 0.1);
    var c = sColors[layer % sColors.length];
    var grad = orbCtx.createRadialGradient(lx, ly, 0, lx, ly, layerR * 1.2);
    grad.addColorStop(0, "rgba(" + c.r + "," + c.g + "," + c.b + "," + layerAlpha + ")");
    grad.addColorStop(0.6, "rgba(" + c.r + "," + c.g + "," + c.b + "," + (layerAlpha * 0.5) + ")");
    grad.addColorStop(1, "rgba(" + c.r + "," + c.g + "," + c.b + ",0)");
    orbCtx.fillStyle = grad;
    orbCtx.fillRect(0, 0, W, H);
  }

  /* ---- BLOBS (internal flowing fog motion with boundary fade) ---- */
  var blobCount = reducedMotion ? 6 : BLOB_COUNT;
  var bAlpha = snap.blobAlpha;
  for (var i = 0; i < blobCount; i++) {
    var blob = blobs[i];
    var speed = snap.speedScale * blob.speedVariance;
    if (reducedMotion) speed *= 0.5;
    var phase = nowSec * (0.2 + (i * 0.07) + speed * 0.08) + blob.phaseOffset;
    var nx = noise.noise2D(blob.noiseSeed + nowSec * 0.15 * speed, i * 0.3);
    var ny = noise.noise2D(blob.noiseSeed + 100 + nowSec * 0.13 * speed, i * 0.3 + 50);
    var orbitR = blob.orbitRadius * R;
    var x = CX + Math.cos(phase) * orbitR + nx * orbitR * 0.5 + driftX * 0.3;
    var y = CY + Math.sin(phase * 0.9) * orbitR + ny * orbitR * 0.5 + driftY * 0.3;
    var blobR = R * 0.28 + Math.sin(phase * 1.7) * R * 0.05;
    /* Fade blobs near edge */
    var dfc = Math.sqrt((x - CX) * (x - CX) + (y - CY) * (y - CY));
    var bFade = Math.max(0, 1 - dfc / (R * 1.2));
    bFade = Math.pow(bFade, 0.6);
    var c = sColors[blob.colorIdx % sColors.length];
    var bGrad = orbCtx.createRadialGradient(x, y, 0, x, y, blobR);
    bGrad.addColorStop(0, "rgba(" + c.r + "," + c.g + "," + c.b + "," + (bAlpha * bFade) + ")");
    bGrad.addColorStop(1, "rgba(" + c.r + "," + c.g + "," + c.b + ",0)");
    orbCtx.fillStyle = bGrad;
    orbCtx.fillRect(0, 0, W, H);
  }

  /* ---- INNER GLOW ---- */
  var igAlpha = snap.innerGlow;
  var ig = orbCtx.createRadialGradient(CX + driftX, CY + driftY, 0, CX, CY, R * 0.5);
  ig.addColorStop(0, "rgba(" + sColors[0].r + "," + sColors[0].g + "," + sColors[0].b + "," + igAlpha + ")");
  ig.addColorStop(1, "rgba(" + sColors[0].r + "," + sColors[0].g + "," + sColors[0].b + ",0)");
  orbCtx.fillStyle = ig;
  orbCtx.fillRect(0, 0, W, H);

  /* ---- STARS (tiny twinkling points — stars in fog) ---- */
  if (!reducedMotion) {
    var sAlphaBase = snap.starAlpha;
    var oAlphaBase = snap.outerAlpha;
    for (var i = 0; i < stars.length; i++) {
      var st = stars[i];
      var age = nowSec - st.born;
      if (age > st.lifespan) {
        stars[i] = spawnStar(nowSec, st.outer);
        continue;
      }
      var lifeT = age / st.lifespan;
      var alpha = lifeT < 0.1 ? lifeT / 0.1 : lifeT > 0.8 ? (1 - lifeT) / 0.2 : 1.0;
      /* Twinkle */
      var twinkleVal = 0.4 + 0.6 * Math.sin(nowSec * st.twinkleRate + st.twinklePhase);
      alpha *= twinkleVal;
      /* Brightness */
      var baseA = st.outer ? oAlphaBase : sAlphaBase;
      alpha *= st.bright ? baseA : (baseA * 0.6);
      if (alpha < 0.003) continue;

      var pNx = noise.noise2D(st.noiseSeed + nowSec * 0.08, st.noiseSeed * 0.3);
      var orbitSpeed = st.speed * (1 + (1 - st.dist) * 0.5) * snap.speedScale;
      var sAngle = st.angle + nowSec * orbitSpeed;
      var sDist = st.dist * R * (st.outer ? 1.4 : 1) + pNx * R * 0.06;
      var sx = CX + Math.cos(sAngle) * sDist + driftX * (st.outer ? 0.2 : 0.4);
      var sy = CY + Math.sin(sAngle) * sDist + driftY * (st.outer ? 0.2 : 0.4);

      /* Edge fade for interior stars (fog obscures edges) */
      if (!st.outer) {
        var dfc2 = Math.sqrt((sx - CX) * (sx - CX) + (sy - CY) * (sy - CY));
        var edgeFade = Math.max(0, 1 - dfc2 / (R * 1.15));
        edgeFade = Math.pow(edgeFade, 0.4);
        alpha *= edgeFade;
      }
      if (alpha < 0.003) continue;

      var sColor = sColors[st.colorIdx % sColors.length];
      var sSize = st.size * dpr;

      /* Tiny glow halo for bright stars only */
      if (st.bright && alpha > 0.08) {
        var glowR = sSize * 2.5;
        var glow = orbCtx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
        glow.addColorStop(0, "rgba(" + sColor.r + "," + sColor.g + "," + sColor.b + "," + (alpha * 0.3) + ")");
        glow.addColorStop(1, "rgba(" + sColor.r + "," + sColor.g + "," + sColor.b + ",0)");
        orbCtx.fillStyle = glow;
        orbCtx.fillRect(sx - glowR, sy - glowR, glowR * 2, glowR * 2);
      }

      orbCtx.beginPath();
      orbCtx.arc(sx, sy, sSize, 0, Math.PI * 2);
      orbCtx.fillStyle = "rgba(" + sColor.r + "," + sColor.g + "," + sColor.b + "," + alpha + ")";
      orbCtx.fill();
    }
  }

  orbCtx.restore(); /* Undo throb transform */

  /* Noise grain overlay */
  if (grainPattern) {
    var grainDriftX = (nowSec * 12 * dpr) % grainTileSize;
    var grainDriftY = (nowSec * 7 * dpr) % grainTileSize;
    orbCtx.save();
    orbCtx.globalAlpha = 0.025;
    orbCtx.translate(grainDriftX, grainDriftY);
    orbCtx.fillStyle = grainPattern;
    orbCtx.fillRect(
      -grainTileSize,
      -grainTileSize,
      W + (grainTileSize * 2),
      H + (grainTileSize * 2)
    );
    orbCtx.restore();
  }

  /* Flash overlay */
  if (flashState.active) {
    var flashElapsed = nowMs - flashState.startTime;
    if (flashElapsed > flashState.duration) {
      flashState.active = false;
    } else {
      var flashT = flashElapsed / flashState.duration;
      var flashAlpha;
      if (flashT < 0.3) {
        flashAlpha = flashT / 0.3;
      } else {
        flashAlpha = 1 - (flashT - 0.3) / 0.7;
      }
      flashAlpha = Math.max(0, flashAlpha * 0.35);
      var flashColor;
      if (flashState.type === "error") {
        flashColor = "rgba(180,60,50," + flashAlpha + ")";
      } else {
        flashColor = "rgba(210,180,60," + flashAlpha + ")";
      }
      /* Apply flash as a soft central radial */
      var flashGrad = orbCtx.createRadialGradient(CX, CY, 0, CX, CY, R);
      flashGrad.addColorStop(0, flashColor);
      flashGrad.addColorStop(1, flashColor.replace(flashAlpha + ")", "0)"));
      orbCtx.fillStyle = flashGrad;
      orbCtx.fillRect(0, 0, W, H);
    }
  }
}

/* ---------------------------------------------------------
   16. Animation Loop
   --------------------------------------------------------- */
function loop(t) {
  var nowMs = t;
  var nowSec = t / 1000;
  var snap = currentSnapshot(nowMs);
  drawOrb(nowSec, nowMs, snap);
  requestAnimationFrame(loop);
}

/* ---------------------------------------------------------
   17. Pointer Events (on scene layer)
   --------------------------------------------------------- */
sceneEl.addEventListener("mousemove", function(event) {
  var rect = sceneEl.getBoundingClientRect();
  pointer.x = (event.clientX - rect.left) / rect.width;
  pointer.y = (event.clientY - rect.top) / rect.height;
  pointer.influence = 1;
});

sceneEl.addEventListener("mouseleave", function() {
  pointer.influence = 0;
});

/* ---------------------------------------------------------
   18. Reduced Motion Listener
   --------------------------------------------------------- */
window.matchMedia("(prefers-reduced-motion: reduce)").addEventListener("change", function(e) {
  reducedMotion = e.matches;
  BLOB_COUNT = reducedMotion ? 6 : 14;
  STAR_COUNT = reducedMotion ? 0 : 100;
  OUTER_STAR_COUNT = reducedMotion ? 0 : 20;
  WISP_COUNT = reducedMotion ? 0 : 8;
  if (reducedMotion) {
    stars = [];
  } else {
    stars = [];
    for (var i = 0; i < STAR_COUNT; i++) {
      var s = spawnStar(0, false);
      s.born = -(Math.random() * s.lifespan);
      stars.push(s);
    }
    for (var i = 0; i < OUTER_STAR_COUNT; i++) {
      var s = spawnStar(0, true);
      s.born = -(Math.random() * s.lifespan);
      stars.push(s);
    }
  }
});

/* ---------------------------------------------------------
   19. Orb Init
   --------------------------------------------------------- */
regenerateGrain();
requestAnimationFrame(loop);

/* =========================================================
   Conversation Layer — Subtitle, Panels, Input
   ========================================================= */

/* ---------------------------------------------------------
   Subtitle System
   --------------------------------------------------------- */
var SUB_DURATION = 5000;
var subFaeTimer = null;
var subUserTimer = null;
var subFae;
var subUser;

function showSubtitle(role, text) {
  var el = role === 'user' ? subUser : subFae;
  var timerKey = role === 'user' ? 'subUserTimer' : 'subFaeTimer';
  clearTimeout(role === 'user' ? subUserTimer : subFaeTimer);
  el.textContent = text;
  el.classList.add('visible');
  var timer = setTimeout(function() {
    el.classList.remove('visible');
  }, SUB_DURATION);
  if (role === 'user') {
    subUserTimer = timer;
  } else {
    subFaeTimer = timer;
  }
}

/* ---------------------------------------------------------
   Message Display (subtitle only — panels are native windows)
   --------------------------------------------------------- */
window.addMessage = function(role, text) {
  showSubtitle(role, text);
};

/* ---------------------------------------------------------
   Listening State
   --------------------------------------------------------- */
window.setListening = function(active) {
  var btn = document.getElementById('listenToggle');
  if (active) {
    btn.classList.add('active');
    btn.classList.remove('inactive');
  } else {
    btn.classList.remove('active');
    btn.classList.add('inactive');
  }
};

/* Typing indicator — no-op, native window handles this now */
window.showTypingIndicator = function() {};

/* Clear subtitles */
window.clearMessages = function() {
  subFae.classList.remove('visible');
  subUser.classList.remove('visible');
};

/* ---------------------------------------------------------
   Swift Bridge
   --------------------------------------------------------- */
function postToSwift(handler, data) {
  if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[handler]) {
    window.webkit.messageHandlers[handler].postMessage(data || {});
  }
}

/* ---------------------------------------------------------
   Init — Wire up DOM and signal ready
   --------------------------------------------------------- */
subFae = document.getElementById('subFae');
subUser = document.getElementById('subUser');

var msgInput = document.getElementById('msgInput');
var sendBtn = document.getElementById('sendBtn');

msgInput.addEventListener('input', function() {
  this.style.height = 'auto';
  this.style.height = Math.min(this.scrollHeight, 120) + 'px';
  sendBtn.disabled = !this.value.trim();
});

msgInput.addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    submitMessage();
  }
});

sendBtn.addEventListener('click', submitMessage);

function submitMessage() {
  var text = msgInput.value.trim();
  if (!text) return;
  window.addMessage('user', text);
  postToSwift('sendMessage', { text: text });
  var urlMatch = text.match(/https?:\/\/[^\s]+/);
  if (urlMatch) {
    postToSwift('linkDetected', { url: urlMatch[0], text: text });
  }
  msgInput.value = '';
  msgInput.style.height = 'auto';
  sendBtn.disabled = true;

  /* Brief visual feedback on send */
  sendBtn.classList.add('sent');
  sendBtn.addEventListener('animationend', function handler() {
    sendBtn.classList.remove('sent');
    sendBtn.removeEventListener('animationend', handler);
  });
}

document.getElementById('listenToggle').addEventListener('click', function() {
  postToSwift('toggleListening', {});
});

/* Action pills open native auxiliary windows */
document.getElementById('showConvBtn').addEventListener('click', function() {
  postToSwift('openConversationWindow', {});
});

document.getElementById('showCanvasBtn').addEventListener('click', function() {
  postToSwift('openCanvasWindow', {});
});

/* ---------------------------------------------------------
   Window Mode API (Swift → JS)
   --------------------------------------------------------- */
window.setWindowMode = function(mode) {
  document.body.dataset.windowMode = mode;
};

/* ---------------------------------------------------------
   Panel Visibility API (Swift → JS)
   Updates pill button labels when panels show/hide.
   --------------------------------------------------------- */
window.setPanelVisibility = function(panel, visible) {
  if (panel === 'conversation') {
    var btn = document.getElementById('showConvBtn');
    if (btn) btn.textContent = visible ? 'Hide Discussions' : 'Show Discussions';
  } else if (panel === 'canvas') {
    var btn = document.getElementById('showCanvasBtn');
    if (btn) btn.textContent = visible ? 'Hide Canvas' : 'Show Canvas';
  }
};

/* ---------------------------------------------------------
   Interaction Tracking (throttled: max 1 report per 5s)
   --------------------------------------------------------- */
var lastInteractionReport = 0;
function reportInteraction() {
  var now = Date.now();
  if (now - lastInteractionReport < 5000) return;
  lastInteractionReport = now;
  postToSwift('userInteraction', {});
}

document.addEventListener('click', reportInteraction);
document.addEventListener('keydown', reportInteraction);

/* ---------------------------------------------------------
   Orb Click — restore from collapsed
   --------------------------------------------------------- */
document.getElementById('scene').addEventListener('click', function() {
  if (document.body.dataset.windowMode === 'collapsed') {
    postToSwift('orbClicked', {});
  }
});

/* ---------------------------------------------------------
   Progress Bar API (Swift → JS)
   --------------------------------------------------------- */
var progressBar = document.getElementById('progressBar');
var progressFill = document.getElementById('progressFill');
var progressLabel = document.getElementById('progressLabel');

window.showProgress = function(stage, message, pct) {
  pct = Math.max(0, Math.min(100, pct || 0));
  progressFill.style.width = pct + '%';
  progressLabel.textContent = message || stage || '';
  progressBar.classList.add('visible');
};

window.setProgress = function(pct) {
  pct = Math.max(0, Math.min(100, pct || 0));
  progressFill.style.width = pct + '%';
};

window.hideProgress = function() {
  progressBar.classList.remove('visible');
  /* Reset fill after fade-out */
  setTimeout(function() {
    if (!progressBar.classList.contains('visible')) {
      progressFill.style.width = '0%';
      progressLabel.textContent = '';
    }
  }, 500);
};

/* ---------------------------------------------------------
   Partial STT Transcription (Swift → JS)
   --------------------------------------------------------- */
window.setSubtitlePartial = function(text) {
  subFae.textContent = '';
  subUser.textContent = text;
  subUser.style.opacity = '0.5';
  subUser.style.fontStyle = 'italic';
  subUser.classList.add('visible');
  /* Do NOT start auto-hide timer for partials */
  clearTimeout(subUserTimer);
};

/* Override addMessage to clear partial state */
var _origAddMessage = window.addMessage;
window.addMessage = function(role, text) {
  if (role === 'user') {
    /* Clear partial styling when final transcription arrives */
    subUser.style.opacity = '';
    subUser.style.fontStyle = '';
  }
  if (typeof _origAddMessage === 'function') { _origAddMessage(role, text); }
};

/* ---------------------------------------------------------
   Streaming Assistant Bubbles (Swift → JS)
   --------------------------------------------------------- */
var pendingAssistantText = '';

window.appendStreamingBubble = function(text) {
  pendingAssistantText += (pendingAssistantText ? ' ' : '') + text;
  subFae.textContent = pendingAssistantText;
  subFae.style.opacity = '0.7';
  subFae.classList.add('visible');
  clearTimeout(subFaeTimer);
};

window.finalizeStreamingBubble = function(fullText) {
  pendingAssistantText = '';
  subFae.style.opacity = '';
  showSubtitle('assistant', fullText || subFae.textContent);
};

/* ---------------------------------------------------------
   Audio Level API (Swift → JS)
   --------------------------------------------------------- */
var smoothedAudioLevel = 0;

window.setAudioLevel = function(rms) {
  /* Exponential moving average for smooth orb response */
  smoothedAudioLevel = smoothedAudioLevel * 0.7 + rms * 0.3;
  /* Only drive urgency during listening mode */
  if (mode === 'listening') {
    urgencyLevel = Math.max(0, Math.min(1, smoothedAudioLevel));
  }
};

/* ---------------------------------------------------------
   Context Menu (right-click on orb)
   --------------------------------------------------------- */
document.getElementById('scene').addEventListener('contextmenu', function(e) {
  e.preventDefault();
  postToSwift('orbContextMenu', { x: e.clientX, y: e.clientY });
});

/* Signal ready to Swift host */
postToSwift('ready', {});
</script>
</body>
</html>
