# Consensus Report — Phase 6.2 Task 7 (Event Wiring)

**Timestamp:** 2026-02-20T15:46:47Z
**Iteration:** 2
**Reviewers:** 15 agents (error-handling, security, code-quality, documentation, test-coverage, type-safety, complexity, build, task-spec, quality-patterns, codex, kimi, glm, minimax, code-simplifier)

---

## Build Status
- `cargo check`: PASS
- `cargo clippy -D warnings`: PASS
- `cargo fmt --check`: PASS
- `cargo test`: PASS (0 failures)

---

## Voting Tally

| Finding | Votes | Severity |
|---------|-------|----------|
| Observer token not stored in FaeNativeApp (.faeDeviceTransfer addObserver) | 6 | SHOULD FIX |
| Duplicate panel visibility match arms in coordinator.rs | 6 | SHOULD FIX |
| voice_command.rs module doc stale ("for runtime model switching") | 3 | INFO |
| No coordinator-level test for ConversationVisibility dispatch | 2 | SHOULD FIX |
| Local `use crate::voice_command::VoiceCommand` inside match arm | 2 | INFO |

---

## MUST FIX (CRITICAL / HIGH)
**None**

## SHOULD FIX (2+ votes)

### Finding A: Observer token not stored (6/15 votes)
**File:** `native/macos/FaeNativeApp/Sources/FaeNativeApp/FaeNativeApp.swift`

The `NotificationCenter.default.addObserver(forName: .faeDeviceTransfer, ...)` call in `onAppear` returns an `NSObjectProtocol` token that is not stored. If `onAppear` fires more than once (window restoration, scene reconnect), duplicate observers accumulate.

**Fix:** Store the returned token. Pattern to use:
```swift
// Add at the top of the wiring block or as a @State variable
var token = NotificationCenter.default.addObserver(
    forName: .faeDeviceTransfer,
    object: nil,
    queue: .main
) { [weak handoff] notification in
    // ... existing handler body ...
}
// Store in an array or use .onDisappear to remove
```

### Finding B: Duplicate coordinator match arms (6/15 votes)
**File:** `src/pipeline/coordinator.rs`

The `ShowConversation/HideConversation/ShowCanvas/HideCanvas` match block is identical in two locations within `run_llm_stage` (~line 1873 and ~line 2139).

**Fix:** Extract to a private helper function:
```rust
fn emit_panel_visibility_events(
    cmd: &VoiceCommand,
    runtime_tx: &Option<broadcast::Sender<RuntimeEvent>>,
) {
    use VoiceCommand::{HideCanvas, HideConversation, ShowCanvas, ShowConversation};
    match cmd {
        ShowConversation | HideConversation => {
            if let Some(rt) = runtime_tx {
                let visible = matches!(cmd, ShowConversation);
                let _ = rt.send(RuntimeEvent::ConversationVisibility { visible });
            }
        }
        ShowCanvas | HideCanvas => {
            if let Some(rt) = runtime_tx {
                let visible = matches!(cmd, ShowCanvas);
                let _ = rt.send(RuntimeEvent::ConversationCanvasVisibility { visible });
            }
        }
        _ => {}
    }
}
```

### Finding C: No coordinator-level test for ConversationVisibility dispatch (2/15 votes)
**File:** `src/pipeline/coordinator.rs`

Handler-level tests exist for the event mapping. No test verifies that the coordinator dispatches the events when ShowConversation/ShowCanvas voice commands arrive.

**Fix:** Add a coordinator integration test (or note as a known coverage gap). Given coordinator test complexity, this is lower priority than A and B.

---

## INFO Only (no fix required)

- **voice_command.rs module doc stale** — minor, not blocking
- **Local use statement inside match arm** — style preference, not blocking

---

## External Grades

| Reviewer | Grade |
|----------|-------|
| Codex | B+ |
| Kimi K2 | B+ |
| GLM-4.7 | B+ |
| MiniMax | A- |

All grades B or higher — threshold met.

---

## Verdict

**CONDITIONAL PASS — 2 SHOULD FIX items, 0 MUST FIX items**

The implementation is functionally complete, all build checks pass, and all 7 phase tasks are implemented correctly. Two code quality improvements are recommended before marking the phase complete:

1. Store the `.faeDeviceTransfer` observer token (prevents duplicate observers)
2. Extract duplicate coordinator panel-visibility match arms to a helper

These are quality improvements, not correctness blockers. The implementation is ready for use in dogfood builds after applying the fixes.
