# Consensus Review — Phase 1.2 Tasks 1, 2, 6, 7
**Generated:** 2026-02-19T01:35:55Z
**Scope:** src/host/handler.rs, src/host/channel.rs, src/ffi.rs, tests/capability_bridge_e2e.rs, tests/onboarding_lifecycle.rs
**Tasks Reviewed:** 1 (pipeline fields), 2 (FFI wiring), 6 (stop/status), 7 (tests)

---

## Build Status: PASS

```
cargo check: PASS (0 errors, 0 warnings)
cargo clippy -D warnings: PASS (0 violations)
cargo nextest run: PASS (2099/2099 tests, 4 skipped)
cargo fmt --check: PASS
```

---

## Vote Tally

| Finding | Severity | Votes | Reviewers |
|---------|----------|-------|-----------|
| Duplicate runtime.started/stopped events | MUST FIX | 6/11 | quality-patterns, complexity, codex, kimi, glm, minimax |
| TOCTOU race in request_runtime_start | SHOULD FIX | 5/11 | error-handling, code-quality, codex, kimi, glm |
| Missing test: inject_text/gate_set when pipeline stopped | SHOULD FIX | 3/11 | test-coverage, codex, kimi |
| Silent lock failures in request_runtime_start | SHOULD FIX | 2/11 | error-handling, code-quality |
| Excessive sequential lock acquisitions — refactor | SHOULD FIX | 3/11 | code-quality, complexity, code-simplifier |

---

## MUST FIX (≥2 votes)

### 1. Duplicate event emission for runtime.started and runtime.stopped

**Location:** `src/host/channel.rs:612-614, 624-626` AND `src/host/handler.rs:336, 395`

**Problem:** Both the `HostCommandServer::handle_runtime_start` and
`FaeDeviceTransferHandler::request_runtime_start` emit `"runtime.started"`.
Similarly both emit `"runtime.stopped"`. Swift callers receive two identical events
per lifecycle transition.

```
Sequence:
  Swift → command_channel → server.handle_runtime_start()
    → handler.request_runtime_start()
      → self.emit_event("runtime.starting", ...)   ← from handler (ok - unique)
      → self.emit_event("runtime.started", ...)    ← from handler (FIRST)
    ← handler returns Ok
  → server.emit_event("runtime.started", ...)      ← from server (DUPLICATE)
```

**Fix:** Remove `emit_event("runtime.started", ...)` from `channel.rs:handle_runtime_start`
and `emit_event("runtime.stopped", ...)` from `channel.rs:handle_runtime_stop`.
The handler owns the lifecycle events; the server should not re-emit them.

Alternatively, remove from handler.rs and let server.rs be the sole emitter — but then
the handler-level `"runtime.starting"` event (which the server doesn't emit) would also
need to move.

**Recommended fix location:** Remove server-level emit in channel.rs lines 612-614 and 624-626.
Keep handler-level emissions (which include the `runtime.starting` event not present in server).

---

## SHOULD FIX (≥2 votes)

### 2. TOCTOU race condition in request_runtime_start

**Location:** `src/host/handler.rs:296-307`

**Problem:** State is read with one lock acquisition then written with a second:
```rust
let current = self.pipeline_state();  // lock released
match current { ... }                  // decision on stale value
// ← another thread can enter here
if let Ok(mut guard) = self.pipeline_state.lock() {
    *guard = PipelineState::Starting;  // late write
}
```

**Fix:** Acquire the state lock once and use it for both the guard check and the transition:
```rust
let mut state_guard = self.pipeline_state
    .lock()
    .map_err(|e| SpeechError::Pipeline(format!("state lock poisoned: {e}")))?;
match *state_guard {
    PipelineState::Running | PipelineState::Starting => {
        return Err(SpeechError::Pipeline(...));
    }
    _ => {}
}
*state_guard = PipelineState::Starting;
drop(state_guard);  // release before spawning task
```

---

### 3. Missing tests for inject_text and gate_set when pipeline is stopped

**Location:** `src/host/handler.rs` (test module)

**Problem:** No test verifies behavior when `text_injection_tx` or `gate_cmd_tx` is None
(pipeline not started). The code silently returns `Ok(())` — this should be tested.

**Fix:** Add two unit tests:
```rust
#[test]
fn inject_text_when_pipeline_stopped_succeeds_silently() {
    let (handler, _dir, _rt) = temp_handler();
    // Pipeline not started, tx is None
    let result = handler.request_conversation_inject_text("hello");
    assert!(result.is_ok());  // silent drop, not an error
}

#[test]
fn gate_set_when_pipeline_stopped_succeeds_silently() {
    let (handler, _dir, _rt) = temp_handler();
    let result = handler.request_conversation_gate_set(true);
    assert!(result.is_ok());
}
```

---

### 4. Silent lock failures in request_runtime_start state transitions

**Location:** `src/host/handler.rs:306-328`

**Problem:** After the initial state check, subsequent lock acquisitions use `if let Ok`
which silently swallows poisoned-mutex errors. If any lock fails, state is partially
updated.

**Fix:** Use `?` operator with consistent error mapping, or accept silent failure
with a comment explaining why it is intentional.

---

### 5. Excessive sequential lock acquisitions — extract helpers

**Location:** `src/host/handler.rs:294-337, 340-397`

**Problem:** Both `request_runtime_start` and `request_runtime_stop` acquire 5-8 separate
mutexes sequentially, each with a `if let Ok` guard. This is verbose and brittle.

**Suggestion:** Extract `lock_pipeline_state` helper following the existing `lock_config`
pattern. Apply consistently to reduce boilerplate.

---

## INFO (no fix required)

- `inject_text` and `gate_set` silently succeed when pipeline stopped — acceptable behavior, test coverage would suffice
- `emit_event` doc could mention both "no receivers" and "buffer full" cases
- `FaeDeviceTransferHandler` struct has 12 fields — large but acceptable for this phase
- `pipeline_started_at` uses `std::time::Instant` — correct choice
- `tool_approval_tx` and `event_bridge_handle` fields are unused stubs — correct scaffolding for Tasks 3-5
- Double event emission produces 1x `runtime.starting`, 2x `runtime.started`, 2x `runtime.stopped` on the Swift bus

---

## Task Completion: PASS (with findings)

All four specified tasks (1, 2, 6, 7) meet their acceptance criteria:
- cargo check ✓
- zero clippy warnings ✓
- all existing tests pass ✓
- new lifecycle tests added ✓

---

## External Reviewer Grades

| Reviewer | Grade |
|----------|-------|
| Codex | B+ |
| Kimi K2 | B+ |
| GLM-4.7 | B |
| MiniMax | B+ |

**Average: B+**

---

## VERDICT: CONDITIONAL PASS — REQUIRES FIX BEFORE PROCEEDING

**Action required:** Fix the duplicate event emission (MUST FIX #1) before Tasks 3-5
are implemented. The TOCTOU and missing tests are SHOULD FIX but lower urgency.

The duplicate event issue will be amplified significantly once Tasks 3-5 add real
pipeline events to the bus. Fix it now before the blast radius grows.

---

## Recommended Fix Sequence

1. Remove duplicate `emit_event` calls from `channel.rs:handle_runtime_start` (line 613-614)
   and `channel.rs:handle_runtime_stop` (lines 625-626)
2. Fix TOCTOU race in `request_runtime_start` — single lock acquisition for check + transition
3. Add 2 missing tests for inject_text/gate_set when pipeline stopped
4. (Optional/low urgency) Extract `lock_pipeline_state` helper to reduce boilerplate
