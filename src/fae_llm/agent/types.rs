//! Configuration and result types for the agent loop.
//!
//! Provides [`AgentConfig`] for controlling loop behavior (turn limits,
//! timeouts) and [`AgentLoopResult`] for capturing the outcome of an
//! agent run including all turns, tool calls, and usage.

use serde::{Deserialize, Serialize};

use crate::fae_llm::events::FinishReason;
use crate::fae_llm::tools::types::ToolResult;
use crate::fae_llm::usage::TokenUsage;

/// Default maximum number of turns in the agent loop.
pub const DEFAULT_MAX_TURNS: u32 = 25;

/// Default maximum tool calls allowed per turn.
pub const DEFAULT_MAX_TOOL_CALLS_PER_TURN: u32 = 10;

/// Default request timeout in seconds.
pub const DEFAULT_REQUEST_TIMEOUT_SECS: u64 = 120;

/// Default per-tool execution timeout in seconds.
pub const DEFAULT_TOOL_TIMEOUT_SECS: u64 = 30;

/// Configuration for the agent loop.
///
/// Controls safety limits (max turns, max tool calls per turn),
/// timeouts (request and per-tool), and the system prompt.
///
/// # Examples
///
/// ```
/// use fae::fae_llm::agent::types::AgentConfig;
///
/// let config = AgentConfig::new()
///     .with_max_turns(10)
///     .with_max_tool_calls_per_turn(5)
///     .with_request_timeout_secs(60)
///     .with_tool_timeout_secs(15)
///     .with_system_prompt("You are a helpful coding assistant.");
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentConfig {
    /// Maximum number of turns (provider round-trips) before stopping.
    pub max_turns: u32,
    /// Maximum tool calls the model may request in a single turn.
    pub max_tool_calls_per_turn: u32,
    /// Timeout for each provider request in seconds.
    pub request_timeout_secs: u64,
    /// Timeout for each individual tool execution in seconds.
    pub tool_timeout_secs: u64,
    /// Optional system prompt prepended to every conversation.
    pub system_prompt: Option<String>,
}

impl Default for AgentConfig {
    fn default() -> Self {
        Self {
            max_turns: DEFAULT_MAX_TURNS,
            max_tool_calls_per_turn: DEFAULT_MAX_TOOL_CALLS_PER_TURN,
            request_timeout_secs: DEFAULT_REQUEST_TIMEOUT_SECS,
            tool_timeout_secs: DEFAULT_TOOL_TIMEOUT_SECS,
            system_prompt: None,
        }
    }
}

impl AgentConfig {
    /// Create a new agent config with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the maximum number of turns.
    pub fn with_max_turns(mut self, max_turns: u32) -> Self {
        self.max_turns = max_turns;
        self
    }

    /// Set the maximum tool calls per turn.
    pub fn with_max_tool_calls_per_turn(mut self, max: u32) -> Self {
        self.max_tool_calls_per_turn = max;
        self
    }

    /// Set the request timeout in seconds.
    pub fn with_request_timeout_secs(mut self, secs: u64) -> Self {
        self.request_timeout_secs = secs;
        self
    }

    /// Set the per-tool execution timeout in seconds.
    pub fn with_tool_timeout_secs(mut self, secs: u64) -> Self {
        self.tool_timeout_secs = secs;
        self
    }

    /// Set the system prompt.
    pub fn with_system_prompt(mut self, prompt: impl Into<String>) -> Self {
        self.system_prompt = Some(prompt.into());
        self
    }
}

/// A tool call that was executed during the agent loop.
///
/// Contains the original call information, the execution result,
/// and timing data.
#[derive(Debug, Clone)]
pub struct ExecutedToolCall {
    /// The unique call ID from the LLM.
    pub call_id: String,
    /// The function name that was called.
    pub function_name: String,
    /// The parsed arguments.
    pub arguments: serde_json::Value,
    /// The tool execution result.
    pub result: ToolResult,
    /// How long the tool took to execute in milliseconds.
    pub duration_ms: u64,
}

/// The result of a single turn in the agent loop.
///
/// A turn is one round-trip: send messages to the provider,
/// receive a streamed response, and optionally execute tool calls.
#[derive(Debug, Clone)]
pub struct TurnResult {
    /// Text generated by the model in this turn.
    pub text: String,
    /// Thinking/reasoning text (if the model produced it).
    pub thinking: String,
    /// Tool calls that were executed in this turn.
    pub tool_calls: Vec<ExecutedToolCall>,
    /// Why the model stopped generating in this turn.
    pub finish_reason: FinishReason,
    /// Token usage for this turn (if reported by the provider).
    pub usage: Option<TokenUsage>,
}

/// Why the agent loop stopped.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum StopReason {
    /// The model completed its response naturally.
    Complete,
    /// The maximum number of turns was reached.
    MaxTurns,
    /// Too many tool calls in a single turn.
    MaxToolCalls,
    /// The loop was cancelled by the caller.
    Cancelled,
    /// An error occurred during the loop.
    Error(String),
}

impl std::fmt::Display for StopReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Complete => write!(f, "complete"),
            Self::MaxTurns => write!(f, "max_turns"),
            Self::MaxToolCalls => write!(f, "max_tool_calls"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::Error(msg) => write!(f, "error: {msg}"),
        }
    }
}

/// The complete result of an agent loop run.
///
/// Contains all turns, the final accumulated text, total token usage,
/// and the reason the loop stopped.
#[derive(Debug, Clone)]
pub struct AgentLoopResult {
    /// All turns executed during the loop.
    pub turns: Vec<TurnResult>,
    /// The final text output (from the last turn's text).
    pub final_text: String,
    /// Total token usage accumulated across all turns.
    pub total_usage: TokenUsage,
    /// Why the agent loop stopped.
    pub stop_reason: StopReason,
}

#[cfg(test)]
mod tests {
    use super::*;

    // ── AgentConfig ──────────────────────────────────────────

    #[test]
    fn agent_config_defaults() {
        let config = AgentConfig::new();
        assert_eq!(config.max_turns, DEFAULT_MAX_TURNS);
        assert_eq!(config.max_tool_calls_per_turn, DEFAULT_MAX_TOOL_CALLS_PER_TURN);
        assert_eq!(config.request_timeout_secs, DEFAULT_REQUEST_TIMEOUT_SECS);
        assert_eq!(config.tool_timeout_secs, DEFAULT_TOOL_TIMEOUT_SECS);
        assert!(config.system_prompt.is_none());
    }

    #[test]
    fn agent_config_builder() {
        let config = AgentConfig::new()
            .with_max_turns(10)
            .with_max_tool_calls_per_turn(5)
            .with_request_timeout_secs(60)
            .with_tool_timeout_secs(15)
            .with_system_prompt("You are helpful.");
        assert_eq!(config.max_turns, 10);
        assert_eq!(config.max_tool_calls_per_turn, 5);
        assert_eq!(config.request_timeout_secs, 60);
        assert_eq!(config.tool_timeout_secs, 15);
        assert_eq!(config.system_prompt.as_deref(), Some("You are helpful."));
    }

    #[test]
    fn agent_config_serde_round_trip() {
        let original = AgentConfig::new()
            .with_max_turns(8)
            .with_system_prompt("test prompt");
        let json = serde_json::to_string(&original).unwrap_or_default();
        let parsed: Result<AgentConfig, _> = serde_json::from_str(&json);
        assert!(parsed.is_ok());
        let parsed = match parsed {
            Ok(c) => c,
            Err(_) => unreachable!("deserialization succeeded"),
        };
        assert_eq!(parsed.max_turns, 8);
        assert_eq!(parsed.system_prompt.as_deref(), Some("test prompt"));
    }

    #[test]
    fn agent_config_clone() {
        let config = AgentConfig::new().with_max_turns(5);
        let cloned = config.clone();
        assert_eq!(cloned.max_turns, 5);
    }

    #[test]
    fn agent_config_debug() {
        let config = AgentConfig::new();
        let debug = format!("{config:?}");
        assert!(debug.contains("AgentConfig"));
        assert!(debug.contains("max_turns"));
    }

    #[test]
    fn agent_config_is_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<AgentConfig>();
    }

    // ── ExecutedToolCall ──────────────────────────────────────

    #[test]
    fn executed_tool_call_construction() {
        let call = ExecutedToolCall {
            call_id: "call_1".into(),
            function_name: "read".into(),
            arguments: serde_json::json!({"path": "main.rs"}),
            result: ToolResult::success("fn main() {}".to_string()),
            duration_ms: 42,
        };
        assert_eq!(call.call_id, "call_1");
        assert_eq!(call.function_name, "read");
        assert_eq!(call.duration_ms, 42);
        assert!(call.result.success);
    }

    #[test]
    fn executed_tool_call_clone() {
        let call = ExecutedToolCall {
            call_id: "call_1".into(),
            function_name: "bash".into(),
            arguments: serde_json::json!({"command": "ls"}),
            result: ToolResult::success("file.txt".to_string()),
            duration_ms: 100,
        };
        let cloned = call.clone();
        assert_eq!(cloned.call_id, "call_1");
        assert_eq!(cloned.duration_ms, 100);
    }

    #[test]
    fn executed_tool_call_debug() {
        let call = ExecutedToolCall {
            call_id: "call_1".into(),
            function_name: "read".into(),
            arguments: serde_json::json!({}),
            result: ToolResult::success("ok".to_string()),
            duration_ms: 5,
        };
        let debug = format!("{call:?}");
        assert!(debug.contains("ExecutedToolCall"));
        assert!(debug.contains("call_1"));
    }

    // ── TurnResult ───────────────────────────────────────────

    #[test]
    fn turn_result_text_only() {
        let turn = TurnResult {
            text: "Hello world".into(),
            thinking: String::new(),
            tool_calls: Vec::new(),
            finish_reason: FinishReason::Stop,
            usage: Some(TokenUsage::new(100, 50)),
        };
        assert_eq!(turn.text, "Hello world");
        assert!(turn.tool_calls.is_empty());
        assert_eq!(turn.finish_reason, FinishReason::Stop);
    }

    #[test]
    fn turn_result_with_tools() {
        let tool_call = ExecutedToolCall {
            call_id: "call_1".into(),
            function_name: "read".into(),
            arguments: serde_json::json!({"path": "test.rs"}),
            result: ToolResult::success("content".to_string()),
            duration_ms: 10,
        };
        let turn = TurnResult {
            text: "I'll read that.".into(),
            thinking: String::new(),
            tool_calls: vec![tool_call],
            finish_reason: FinishReason::ToolCalls,
            usage: None,
        };
        assert_eq!(turn.tool_calls.len(), 1);
        assert_eq!(turn.finish_reason, FinishReason::ToolCalls);
    }

    #[test]
    fn turn_result_with_thinking() {
        let turn = TurnResult {
            text: "Answer: 42".into(),
            thinking: "Let me think step by step...".into(),
            tool_calls: Vec::new(),
            finish_reason: FinishReason::Stop,
            usage: None,
        };
        assert_eq!(turn.thinking, "Let me think step by step...");
    }

    #[test]
    fn turn_result_clone() {
        let turn = TurnResult {
            text: "test".into(),
            thinking: String::new(),
            tool_calls: Vec::new(),
            finish_reason: FinishReason::Stop,
            usage: None,
        };
        let cloned = turn.clone();
        assert_eq!(cloned.text, "test");
    }

    // ── StopReason ───────────────────────────────────────────

    #[test]
    fn stop_reason_display() {
        assert_eq!(StopReason::Complete.to_string(), "complete");
        assert_eq!(StopReason::MaxTurns.to_string(), "max_turns");
        assert_eq!(StopReason::MaxToolCalls.to_string(), "max_tool_calls");
        assert_eq!(StopReason::Cancelled.to_string(), "cancelled");
        assert_eq!(
            StopReason::Error("timeout".into()).to_string(),
            "error: timeout"
        );
    }

    #[test]
    fn stop_reason_equality() {
        assert_eq!(StopReason::Complete, StopReason::Complete);
        assert_ne!(StopReason::Complete, StopReason::MaxTurns);
        assert_eq!(
            StopReason::Error("a".into()),
            StopReason::Error("a".into())
        );
        assert_ne!(
            StopReason::Error("a".into()),
            StopReason::Error("b".into())
        );
    }

    #[test]
    fn stop_reason_serde_round_trip() {
        let reasons = [
            StopReason::Complete,
            StopReason::MaxTurns,
            StopReason::MaxToolCalls,
            StopReason::Cancelled,
            StopReason::Error("something".into()),
        ];
        for reason in &reasons {
            let json = serde_json::to_string(reason).unwrap_or_default();
            let parsed: Result<StopReason, _> = serde_json::from_str(&json);
            assert!(parsed.is_ok(), "failed to parse: {json}");
            match parsed {
                Ok(r) => assert_eq!(r, *reason),
                Err(_) => unreachable!("deserialization succeeded"),
            }
        }
    }

    #[test]
    fn stop_reason_clone() {
        let reason = StopReason::Error("test".into());
        let cloned = reason.clone();
        assert_eq!(reason, cloned);
    }

    #[test]
    fn stop_reason_debug() {
        let reason = StopReason::Complete;
        let debug = format!("{reason:?}");
        assert!(debug.contains("Complete"));
    }

    // ── AgentLoopResult ──────────────────────────────────────

    #[test]
    fn agent_loop_result_construction() {
        let turn = TurnResult {
            text: "Done.".into(),
            thinking: String::new(),
            tool_calls: Vec::new(),
            finish_reason: FinishReason::Stop,
            usage: Some(TokenUsage::new(200, 100)),
        };
        let result = AgentLoopResult {
            turns: vec![turn],
            final_text: "Done.".into(),
            total_usage: TokenUsage::new(200, 100),
            stop_reason: StopReason::Complete,
        };
        assert_eq!(result.turns.len(), 1);
        assert_eq!(result.final_text, "Done.");
        assert_eq!(result.total_usage.total(), 300);
        assert_eq!(result.stop_reason, StopReason::Complete);
    }

    #[test]
    fn agent_loop_result_multi_turn() {
        let turn1 = TurnResult {
            text: "Let me check.".into(),
            thinking: String::new(),
            tool_calls: vec![ExecutedToolCall {
                call_id: "call_1".into(),
                function_name: "read".into(),
                arguments: serde_json::json!({"path": "a.rs"}),
                result: ToolResult::success("code".to_string()),
                duration_ms: 10,
            }],
            finish_reason: FinishReason::ToolCalls,
            usage: Some(TokenUsage::new(100, 50)),
        };
        let turn2 = TurnResult {
            text: "Here's the file.".into(),
            thinking: String::new(),
            tool_calls: Vec::new(),
            finish_reason: FinishReason::Stop,
            usage: Some(TokenUsage::new(150, 80)),
        };
        let mut total = TokenUsage::new(100, 50);
        total.add(&TokenUsage::new(150, 80));
        let result = AgentLoopResult {
            turns: vec![turn1, turn2],
            final_text: "Here's the file.".into(),
            total_usage: total,
            stop_reason: StopReason::Complete,
        };
        assert_eq!(result.turns.len(), 2);
        assert_eq!(result.total_usage.prompt_tokens, 250);
        assert_eq!(result.total_usage.completion_tokens, 130);
    }

    #[test]
    fn agent_loop_result_clone() {
        let result = AgentLoopResult {
            turns: Vec::new(),
            final_text: "test".into(),
            total_usage: TokenUsage::default(),
            stop_reason: StopReason::Complete,
        };
        let cloned = result.clone();
        assert_eq!(cloned.final_text, "test");
    }

    #[test]
    fn agent_loop_result_debug() {
        let result = AgentLoopResult {
            turns: Vec::new(),
            final_text: "output".into(),
            total_usage: TokenUsage::default(),
            stop_reason: StopReason::Complete,
        };
        let debug = format!("{result:?}");
        assert!(debug.contains("AgentLoopResult"));
        assert!(debug.contains("output"));
    }

    #[test]
    fn all_agent_types_are_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<AgentConfig>();
        assert_send_sync::<StopReason>();
        // ExecutedToolCall, TurnResult, AgentLoopResult contain ToolResult
        // which has String fields — all Send + Sync
        assert_send_sync::<ExecutedToolCall>();
        assert_send_sync::<TurnResult>();
        assert_send_sync::<AgentLoopResult>();
    }
}
